{"FileModelVersion":{"Major":1,"Minor":0},"Name":"aE-III Huge Missile Interceptor","Version":35,"SavedTotalBlockCount":72,"SavedMaterialCost":1581.90015,"ContainedMaterialCost":60.0,"ItemDictionary":{"710":"8600329a-4b2b-44c7-8e66-634b0d81ce3d","1642":"cac80cc3-1d8e-4c2e-b904-09ba3374f940","695":"d4e23d98-fbde-449e-823f-872004cadc7a","189":"26a604f0-071c-49ca-8a0e-e1d9c959b1c5","150":"d3924bae-be5a-43a0-be19-64fc7c8d6059","236":"a56e0dcf-94e4-48a0-b8b9-5e33e0ab69cf","693":"4934fff3-aca3-4fb3-b242-60afbe8d4439","718":"c8fe583a-357b-4fa6-86f1-fc2de639c909","1644":"02008b7b-1f99-4333-88f8-bb07a0e7e857","312":"9f59f0aa-4a84-49d3-ac0b-1f65b3308324","121":"e63040c9-0027-4fd3-be30-67fe3e950140","109":"cdca5dec-eeee-4849-9b2e-73b23e216465","653":"b50989c9-03d4-4201-a8d4-459dcea86b05","603":"aecb98bb-76cd-4d05-8304-acc1392ab596","217":"1725c9ed-29fd-438d-97f6-8f645a1865d4","191":"23b1fef3-0556-4a51-88fc-d4a223c3e934","234":"e6bb2b09-daee-432d-9aff-45fc63d24fca","903":"8f9dbf41-6c2d-4e7b-855d-b2432c6942a2","108":"788700be-1e74-46d7-9e34-1a5ec2747548","119":"c5cec892-2e43-4905-9d28-44fc8ecb5cc7","120":"213026bc-fd7a-44e6-b543-a31c219aaef0","1646":"2b58c066-e38e-4a21-af64-17b2bb5bed0d","287":"f675b19a-4a67-41de-bd60-651bac2cfe17","798":"e8c5c921-b116-45cd-b0de-7a37973d5158","799":"819dea06-da54-4236-a041-7346e3dad3d2"},"Blueprint":{"ContainedMaterialCost":60.0,"CSI":[0.0,0.0,-1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,128.025284,736.7417,-1.0,0.0,0.0,1.0,1.0,30000.0,0.0,0.0,0.0,5.42500162,0.0,0.1,0.1,1.0,1.0,3.0,0.0,0.0,3999.13574,0.0,-1.0,1.0,0.0,100.0,0.0,0.0,178.9787,29990.541,30000.0,100.0,0.0,-1.0,70.75,0.0,0.0,0.0,0.0,500.0,0.0,12.0,0.0,0.0,0.0,0.815475,0.0,0.0,0.0,0.0,0.0063215117,0.0,0.0,0.0,0.0,1.0,1.0,-1.0,-1.0,-1.0,-1.0],"COL":["0.011764,0,0,0","1,0,0,0.5","0,1,0,0.5","0,0,1,0.5","0.1,0.1,0.1,0.5","0.3,0.3,0.3,0.5","0.5,0.5,0.5,0.5","1,1,1,0.1","1,1,1,0.5","1,1,1,0.99","1,0.921568,0.015686,0.99","0,1,1,0.99","1,0,1,0.99","0.864626,0.434472,0.299871,0.828378","0.586869,0.457345,0.919997,0.259799","0.758084,0.087803,0.970369,0.217299","0.276548,0.957477,0.582312,0.015006","0.903853,0.73457,0.010718,0.837852","0.704795,0.930329,0.158059,0.448773","0.181419,0.358234,0.140033,0.07254","0.614556,0.703575,0.675773,0.554264","0.612402,0.350909,0.144586,0.884375","0.370666,0.181325,0.581195,0.770752","0.620983,0.602118,0.377514,0.740896","0.901199,0.558145,0.781935,0.291857","0.309837,0.247915,0.670469,0.101442","0.340285,0.180928,0.158589,0.924019","0,0,0,0","0.188235,0,0.4,0.5","0.019607,1,1,1","0.980392,1,1,1","0,0,0,1"],"SCs":[{"ContainedMaterialCost":0.0,"CSI":[-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0],"COL":null,"SCs":[{"ContainedMaterialCost":0.0,"CSI":[-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0],"COL":null,"SCs":[],"BLP":["0,0,0"],"BLR":[0],"BP1":null,"BP2":null,"BCI":[0],"BEI":null,"BlockData":"AAAAKgAAAA4AAwAAAAAAAAEAAAAAAAACAAAAAAAAdiYAAAAHAEIYAAAABwBdGwEAAAcAAQAECtcjPAAABIwAAAA=","VehicleData":"Vy4AAAAAAAAHAAAAAAAAAAAAAAAA8FsKAQAAAAAOAAAAAAAPJwAAAAAA0AcAAAAAAJ9xBAAAAAAADgAAAAAADycAAAAAAKCGAQAAAABHKQEAAAAAAAcAAAAAAAAAAAAAAAA=","designChanged":false,"blueprintVersion":0,"blueprintName":"Two Axis Turret","SerialisedInfo":{"JsonDictionary":{},"IsEmpty":true},"Name":null,"ItemNumber":120,"LocalPosition":"0,-1,3","LocalRotation":"0,0,-0.999999,0","ForceId":0,"TotalBlockCount":1,"MaxCords":"0,0,0","MinCords":"0,0,0","BlockIds":[119],"BlockState":"0","AliveCount":1,"BlockStringData":[],"BlockStringDataIds":[],"GameVersion":"3.2.9.7","PersistentSubObjectIndex":21,"PersistentBlockIndex":-1,"AuthorDetails":{"Valid":true,"ForeignBlocks":0,"CreatorId":"051780ed-f58a-41a6-b60f-84fb260c1b22","ObjectId":"ce7c7310-16d6-431b-9340-de70f11de25e","CreatorReadableName":"DreekFire","HashV1":"43488cf16db2c12d7c9a62d3ae84e2ff"},"BlockCount":1},{"ContainedMaterialCost":0.0,"CSI":[-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0],"COL":null,"SCs":[],"BLP":["0,0,0","0,0,-1","0,0,-3","0,0,-4","0,1,-4","0,-1,-4","0,0,-5","0,1,-5","0,-1,-5"],"BLR":[0,14,17,17,9,5,17,17,17],"BP1":null,"BP2":null,"BCI":[0,0,0,0,0,0,0,0,0],"BEI":null,"BlockData":"AAAAKgAAABwAAQAAAAAAAAIAAAAABAADAAAAAAQAJIgAAAALAF0AAAAACwBdGwEAAAsACQABAWQABAAA8EEAAASdAAAAAQAHdG9wU3Bpbg==","VehicleData":"Vy4AAAAAAAAHAAAAAAAAAAAAAAAA8FsKAQAAAAAOAAAAAAAPJwAAAAAA0AcAAAAAAJ9xBAAAAAAADgAAAAAADycAAAAAAKCGAQAAAABHKQEAAAAAAAcAAAAAAAAAAAAAAAA=","designChanged":false,"blueprintVersion":0,"blueprintName":"Swatter","SerialisedInfo":{"JsonDictionary":{},"IsEmpty":true},"Name":null,"ItemNumber":108,"LocalPosition":"0,1,5","LocalRotation":"0,0,0.707106,0.707106","ForceId":0,"TotalBlockCount":9,"MaxCords":"0,1,0","MinCords":"0,-1,-5","BlockIds":[109,1646,287,287,798,799,287,287,287],"BlockState":"=0,9","AliveCount":9,"BlockStringData":[],"BlockStringDataIds":[],"GameVersion":"3.2.9.7","PersistentSubObjectIndex":26,"PersistentBlockIndex":-1,"AuthorDetails":{"Valid":true,"ForeignBlocks":0,"CreatorId":"051780ed-f58a-41a6-b60f-84fb260c1b22","ObjectId":"ce7c7310-16d6-431b-9340-de70f11de25e","CreatorReadableName":"DreekFire","HashV1":"43488cf16db2c12d7c9a62d3ae84e2ff"},"BlockCount":9},{"ContainedMaterialCost":0.0,"CSI":[-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0],"COL":null,"SCs":[],"BLP":["0,0,0","0,0,-1","0,0,-3","0,0,-4","0,1,-4","0,-1,-4","0,1,-5","0,0,-5","0,-1,-5"],"BLR":[0,14,17,17,9,5,17,17,17],"BP1":null,"BP2":null,"BCI":[0,0,0,0,0,0,0,0,0],"BEI":null,"BlockData":"AAAAKgAAACQAAQAAAAAAAAIAAAAABAADAAAAAAsAJIgAAAASAF0AAAAAEgBdGwEAABIACQABAQoABAAAAL9kAAQAAPBBAAAEnQAAAAEACGxlZnRTcGlu","VehicleData":"Vy4AAAAAAAAHAAAAAAAAAAAAAAAA8FsKAQAAAAAOAAAAAAAPJwAAAAAA0AcAAAAAAJ9xBAAAAAAADgAAAAAADycAAAAAAKCGAQAAAABHKQEAAAAAAAcAAAAAAAAAAAAAAAA=","designChanged":false,"blueprintVersion":0,"blueprintName":"Swatter","SerialisedInfo":{"JsonDictionary":{},"IsEmpty":true},"Name":null,"ItemNumber":108,"LocalPosition":"-1,0,5","LocalRotation":"0,0,-0.999999,0","ForceId":0,"TotalBlockCount":9,"MaxCords":"0,1,0","MinCords":"0,-1,-5","BlockIds":[109,1646,287,287,798,799,287,287,287],"BlockState":"=0,9","AliveCount":9,"BlockStringData":[],"BlockStringDataIds":[],"GameVersion":"3.2.9.7","PersistentSubObjectIndex":27,"PersistentBlockIndex":-1,"AuthorDetails":{"Valid":true,"ForeignBlocks":0,"CreatorId":"051780ed-f58a-41a6-b60f-84fb260c1b22","ObjectId":"ce7c7310-16d6-431b-9340-de70f11de25e","CreatorReadableName":"DreekFire","HashV1":"43488cf16db2c12d7c9a62d3ae84e2ff"},"BlockCount":9},{"ContainedMaterialCost":0.0,"CSI":[-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0],"COL":null,"SCs":[],"BLP":["0,0,0","0,0,-1","0,0,-3","0,0,-4","0,1,-4","0,-1,-4","0,1,-5","0,0,-5","0,-1,-5"],"BLR":[0,14,17,17,9,5,17,17,17],"BP1":null,"BP2":null,"BCI":[0,0,0,0,0,0,0,0,0],"BEI":null,"BlockData":"AAAAKgAAACYAAQAAAAAAAAIAAAAABAADAAAAAAsAJIgAAAASAF0AAAAAEgBdGwEAABIACQABAQoABAAAAL9kAAQAAPBBAAAEnQAAAAEACmJvdHRvbVNwaW4=","VehicleData":"Vy4AAAAAAAAHAAAAAAAAAAAAAAAA8FsKAQAAAAAOAAAAAAAPJwAAAAAA0AcAAAAAAJ9xBAAAAAAADgAAAAAADycAAAAAAKCGAQAAAABHKQEAAAAAAAcAAAAAAAAAAAAAAAA=","designChanged":false,"blueprintVersion":0,"blueprintName":"Swatter","SerialisedInfo":{"JsonDictionary":{},"IsEmpty":true},"Name":null,"ItemNumber":108,"LocalPosition":"0,-1,5","LocalRotation":"0,0,-0.707106,0.707106","ForceId":0,"TotalBlockCount":9,"MaxCords":"0,1,0","MinCords":"0,-1,-5","BlockIds":[109,1646,287,287,798,799,287,287,287],"BlockState":"=0,9","AliveCount":9,"BlockStringData":[],"BlockStringDataIds":[],"GameVersion":"3.2.9.7","PersistentSubObjectIndex":28,"PersistentBlockIndex":-1,"AuthorDetails":{"Valid":true,"ForeignBlocks":0,"CreatorId":"051780ed-f58a-41a6-b60f-84fb260c1b22","ObjectId":"ce7c7310-16d6-431b-9340-de70f11de25e","CreatorReadableName":"DreekFire","HashV1":"43488cf16db2c12d7c9a62d3ae84e2ff"},"BlockCount":9},{"ContainedMaterialCost":0.0,"CSI":[-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0],"COL":null,"SCs":[],"BLP":["0,0,0","0,0,-1","0,0,-3","0,0,-4","0,1,-4","0,-1,-4","0,1,-5","0,0,-5","0,-1,-5"],"BLR":[0,14,17,17,9,5,17,17,17],"BP1":null,"BP2":null,"BCI":[0,0,0,0,0,0,0,0,0],"BEI":null,"BlockData":"AAAAKgAAACUAAQAAAAAAAAIAAAAABAADAAAAAAsAJIgAAAASAF0AAAAAEgBdGwEAABIACQABAQoABAAAAL9kAAQAAPBBAAAEnQAAAAEACXJpZ2h0U3Bpbg==","VehicleData":"Vy4AAAAAAAAHAAAAAAAAAAAAAAAA8FsKAQAAAAAOAAAAAAAPJwAAAAAA0AcAAAAAAJ9xBAAAAAAADgAAAAAADycAAAAAAKCGAQAAAABHKQEAAAAAAAcAAAAAAAAAAAAAAAA=","designChanged":false,"blueprintVersion":0,"blueprintName":"Swatter","SerialisedInfo":{"JsonDictionary":{},"IsEmpty":true},"Name":null,"ItemNumber":108,"LocalPosition":"1,0,5","LocalRotation":"0,0,0,0.999999","ForceId":0,"TotalBlockCount":9,"MaxCords":"0,1,0","MinCords":"0,-1,-5","BlockIds":[109,1646,287,287,798,799,287,287,287],"BlockState":"=0,9","AliveCount":9,"BlockStringData":[],"BlockStringDataIds":[],"GameVersion":"3.2.9.7","PersistentSubObjectIndex":29,"PersistentBlockIndex":-1,"AuthorDetails":{"Valid":true,"ForeignBlocks":0,"CreatorId":"051780ed-f58a-41a6-b60f-84fb260c1b22","ObjectId":"ce7c7310-16d6-431b-9340-de70f11de25e","CreatorReadableName":"DreekFire","HashV1":"43488cf16db2c12d7c9a62d3ae84e2ff"},"BlockCount":9}],"BLP":["0,0,0","1,0,0","-1,0,0","0,0,1","-1,0,4","1,0,4","0,-1,4","0,1,4","0,0,3","0,0,2","0,-1,0","0,0,-1","0,0,4","0,0,6"],"BLR":[0,0,0,0,21,20,4,8,0,10,16,2,0,18],"BP1":null,"BP2":null,"BCI":[0,0,0,0,0,0,0,0,0,0,0,0,0,0],"BEI":null,"BlockData":"AAAAKgAAAAcAAQAAAAAAAAIAAAAAAAADAAAAAAAAJIgAAAAAAF0AAAAAAABdGwEAAAAAAAAEfQAAAAEAACoAAAAcAIkAAAAAAAAkiAAAAAAAhnsAAAAAAOxiAAAAFQBdAAAAABUAXRsBAAAVAAAABK5HUUAEAAQAAIA/BwAEAACAPwAABJIAAAACAAAqAAAAHACJAAAAAAAAJIgAAAAAAIZ7AAAAAADsYgAAABUAXQAAAAAVAF0bAQAAFQAAAATD9VBABAAEAACAPwcABAAAgD8AAASTAAAACAAAHAAAAGAAAgAAAAAAAAEAAAAAVQCOHAAAAGAAXRsBAABgAAAABAAAAAABAAQAAAAAAgAEAAAAAAMABAAAAAAEAAQAAAAABQAEAAAAAAYABAAAAAAHAAQAAAAACwAIAACgQAAA+kQMAAgAgLtEAAD6RA4ABAEAAAABAAgAAAAAAIC7RAkAAA4AAAAHAGkBAAAAAABdGwEAAAAAAAAElAAAAAoAABUAAAAOAOYCAAAAAABdAAAAAA4AXRsBAAAOAAEABAAAgD8CAAQAAIA/","VehicleData":"Vy4AAAAAAAAHAAAAAAAAAAAAAAAA8FsKAQAAAAAOAAAAAAAPJwAAAAAA0AcAAAAAAJ9xBAAAAAAADgAAAAAADycAAAAAAKCGAQAAAABHKQEAAAAAAAcAAAAAAAAAAAAAAAA=","designChanged":false,"blueprintVersion":0,"blueprintName":"Spin / Turn block","SerialisedInfo":{"JsonDictionary":{},"IsEmpty":true},"Name":null,"ItemNumber":108,"LocalPosition":"0,0,-4","LocalRotation":"0,0,0,1","ForceId":0,"TotalBlockCount":51,"MaxCords":"1,1,6","MinCords":"-1,-1,-1","BlockIds":[109,653,653,603,217,217,217,217,191,234,695,217,903,217],"BlockState":"=0,14","AliveCount":14,"BlockStringData":[],"BlockStringDataIds":[],"GameVersion":"3.2.9.7","PersistentSubObjectIndex":16,"PersistentBlockIndex":-1,"AuthorDetails":{"Valid":true,"ForeignBlocks":0,"CreatorId":"051780ed-f58a-41a6-b60f-84fb260c1b22","ObjectId":"ce7c7310-16d6-431b-9340-de70f11de25e","CreatorReadableName":"DreekFire","HashV1":"43488cf16db2c12d7c9a62d3ae84e2ff"},"BlockCount":14}],"BLP":["0,0,-2","0,0,-1","1,0,-3","0,1,-4","0,0,-3","0,0,1","0,-1,-3","0,0,2","0,0,3","0,0,0","0,-1,-2","0,1,0","0,-1,-1","1,0,-2","-1,0,-2","-1,0,-4","1,0,-4","-1,0,0","1,0,0","-1,0,-3","0,1,-3"],"BLR":[0,0,1,16,0,0,12,0,16,6,18,4,8,21,20,0,0,20,21,15,11],"BP1":null,"BP2":null,"BCI":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"BEI":null,"BlockData":"AwAAFQAAAA4A5gIAAAAAAF0AAAAADgBdGwEAAA4AAQAEAACAPwIABAAAgL8EAAAjAAAABwAPJwAAAAAAhM0AAAAAAIXNAAAAAACGzQAAAAAAXRsBAAAAAAAABJUAAAAFAAAHAAAABwBdGwEAAAAAAAAElgAAAAYAAA4AAAAHAGkBAAAAAABdGwEAAAAAAAAEmAAAAAkAABwAAAAHAAEAAAAAAADmAgAAAAAAXQAAAAAAAF0bAQAAAAAAAASZAAAADwAAFQAAAA4A5gIAAAAAAF0AAAAADgBdGwEAAA4AAgAEAACAvwMABAAAgD8QAAAVAAAADgDmAgAAAAAAXQAAAAAOAF0bAQAADgACAAQAAIA/AwAEAACAPw==","VehicleData":"Vy4AAAAAAAAHAAAAAAAAAAAAAAAA8FsKAQAAAAAOAAAAAAAPJwAAAAAA0AcAAAAAAJ9xBAAAAAAADgAAAAAADycAAAAAAKCGAQAAAABHKQEAAAAAAAcAAAAAAAAAAAAAAADBfVafAAAAAAcAAAAHAAAAAAAAAAAAAAQBAAAAOe0HAAAAAAAHAAAAAAABAAAAAAAAPjUUAAAAAAAHAAAAHAABAAAAAAAACgAEzczMPQsABM3MzD0MAATNzMw9DQAEzczMPVJDAAAAAAAABwAAAAAAAQAAAAAAAMRKAAAAAAAABwAAAA4AAAAAAAAAAAAABJgbGEgDAATOBz5GK94KAAAAAAAHAAAACAABAAAAAAAAAAABAAEAAQAyjlAAAAAAAAcAAAAAAAAAAAAAAADQq2UAAAAAAA4AAAAUAAAAAAAAAAABAAAAABQAAAABAQEAAQECAAEBAwABAQQAAQHCJ2EAAAAAAAcAAABGAAAAAAAAAAAAAAQAAEhCCgAEAADIwQ8ABAAAXEIUAAQAAPpDGQAEAIA7RTIABABAHEY3AAQAQBxGHgAEAACAPyMABAAAgD8oAAQAAKBB","designChanged":false,"blueprintVersion":35,"blueprintName":"aE-III Huge Missile Interceptor","SerialisedInfo":{"JsonDictionary":{},"IsEmpty":true},"Name":null,"ItemNumber":121,"LocalPosition":"11569.47,114.6259,7786.836","LocalRotation":"0.5563409,-0.2982513,-0.7678972,0.1089258","ForceId":670372365,"TotalBlockCount":72,"MaxCords":"1,1,3","MinCords":"-1,-1,-4","BlockIds":[710,710,1642,695,189,150,236,693,1642,718,1644,312,312,312,312,695,695,312,312,1642,1642],"BlockState":"=0,21","AliveCount":21,"BlockStringData":["local Accumulator = {}\r\nlocal Differ = {}\r\nlocal LinkedList = {}\r\nlocal MathUtil = {}\r\nlocal RingBuffer = {}\r\nlocal Control = {}\r\nlocal Nav = {}\r\nlocal Targeting = {}\r\nlocal BlockUtil = {}\r\nlocal Combat = {}\r\n\r\n-- Settings\r\n-- how far ahead the missile tried to lead the target to beamride into it head on\r\nlocal maxTargetLead = 0.6\r\n-- takes weighted average of TPG and PP guidance\r\n-- set to -1 to use variable weight that scales inversely from 0 to 1\r\nlocal tpgWeight = 1\r\n-- max range to pursue missiles in\r\nlocal maxRange = 1200\r\n-- Flight settings\r\n-- throttle to use for idle flight\r\nlocal idleThrottle = 0.06\r\n-- whether to use heading or velocity to maneuver\r\nlocal maneuverByVelocity = true\r\n\r\n-- names of spinblocks that hold the arms\r\nlocal spinBlockNames = {  top = \"topSpin\",\r\n                          left = \"leftSpin\",\r\n                          right = \"rightSpin\",\r\n                          bottom = \"bottomSpin\" }\r\n\r\n-- Error is represented by rotation vectors instead of degrees\r\n--   so these should be about 90 times the constants for the built-in PID\r\n-- PID settings\r\nlocal PIDSet = {\r\n  P = 1.25,\r\n  I = 0.1,\r\n  D = 0.3,\r\n  IWindow = 0.2,\r\n  IDecay = 0.1\r\n}\r\n\r\nlocal PIDSetIdle = {\r\n  P = 1,\r\n  I = 0,\r\n  D = 0.6,\r\n  IWindow = 0,\r\n  IDecay = 0\r\n}\r\n\r\n-- lower and upper altitude limits\r\n  -- note: terrain avoidance not implemented yet\r\nlocal altFloorWater, altFloorLand, altCeil = 50, 80, 800\r\n-- altitude to fly at when idling\r\nlocal idleAlt = 100\r\n-- radius to circle at when idling\r\nlocal idleRadius = 150\r\n-- adjuster is turned off within this distance of the target\r\n-- to hit submarine, land, or space targets\r\nlocal altViolationZone = 100\r\n-- minimum altitude of missiles to try to intercept\r\nlocal minHeight = 5\r\n\r\n-- averaging time and decay rate for acceleration\r\nlocal accelAvgTime = 0.5\r\nlocal accelAvgDecay = 0.25\r\n\r\n-- misc variables\r\nlocal timeDiff\r\nlocal accelAcc\r\nlocal combatPid, idlePid\r\nlocal pid\r\nlocal currentTargetId\r\nlocal inited = false\r\nlocal circlePoint\r\nlocal armBlocks = {}\r\n\r\nfunction Init(I)\r\n  timeDiff = Differ.Differ(I:GetGameTime())\r\n  accelAcc = Accumulator.Accumulator(accelAvgTime, accelAvgDecay)\r\n  for s, name in pairs(spinBlockNames) do\r\n    armBlocks[s] = BlockUtil.getSubConstructsByName(I, name, 1)[1]\r\n  end\r\n  combatPid = Control.PID(PIDSet.P, PIDSet.I, PIDSet.D, PIDSet.IWindow, PIDSet.IDecay)\r\n  idlePid = Control.PID(PIDSetIdle.P, PIDSetIdle.I, PIDSetIdle.D, PIDSetIdle.IWindow, PIDSetIdle.IDecay)\r\nend\r\n\r\nfunction Update(I)\r\n  if not inited then\r\n    Init(I)\r\n    inited = true\r\n    return\r\n  end\r\n\r\n  I:TellAiThatWeAreTakingControl()\r\n\r\n  local elapsedTime = Differ.update(timeDiff, I:GetGameTime())\r\n\r\n  local desired\r\n  -- determine whether to be in combat or idle mode\r\n  if I:GetNumberOfWarnings() == 0 then\r\n    ResetTargetInfo()\r\n    I:RequestControl(2, 8, idleThrottle)\r\n    pid = idlePid\r\n    desired = Adjust(I, Idle(I))\r\n    for s, id in pairs(armBlocks) do I:SetSpinBlockRotationAngle(id, 0) end\r\n  else\r\n    local target = CheckTarget(I, currentTargetId)\r\n\r\n    if not target or not target.Valid or (target.Position - I:GetConstructPosition()).magnitude > maxRange then\r\n      ResetTargetInfo()\r\n      I:RequestControl(2, 8, idleThrottle)\r\n      pid = idlePid\r\n      desired = Adjust(I, Idle(I))\r\n      for s, id in pairs(armBlocks) do I:SetSpinBlockRotationAngle(id, 0) end\r\n    else\r\n      currentTargetId = target.Id\r\n\r\n      I:RequestControl(2, 8, 1)\r\n      pid = combatPid\r\n      desired = FinalGuidance(I, target)\r\n      local targetRoll = Vector3.SignedAngle(I:GetConstructUpVector(), target.Position - I:GetConstructPosition(), I:GetConstructForwardVector())\r\n      local angles = {top = 0, right = 90, bottom = 180, left = 270}\r\n      local bestAngle = math.huge\r\n      for s, id in pairs(armBlocks) do\r\n        local diff = Mathf.Repeat(targetRoll - angles[s] + 180, 360) - 180\r\n        if I:IsAlive(id) and diff < bestAngle then\r\n          bestAngle = diff\r\n        end\r\n      end\r\n      targetRoll = bestAngle\r\n      if (target.Position - I:GetConstructPosition()).magnitude < 100 then\r\n        for s, id in pairs(armBlocks) do I:SetSpinBlockRotationAngle(id, -90) end\r\n      else\r\n        for s, id in pairs(armBlocks) do I:SetSpinBlockRotationAngle(id, 0) end\r\n      end\r\n    end\r\n  end\r\n\r\n  --PID\r\n  local e = Vector3.Cross(desired, maneuverByVelocity and I:GetVelocityVector().normalized or I:GetConstructForwardVector())\r\n  local correction = Control.processPID(pid, e, elapsedTime) + pid.kD * I:GetAngularVelocity()\r\n\r\n  --steering\r\n  local yawResponse = Vector3.Dot(correction, -I:GetConstructUpVector())\r\n  local pitchResponse = Vector3.Dot(correction, I:GetConstructRightVector())\r\n  local rollResponse = ((targetRoll and 0.05 * targetRoll) or 0) - 0.1 * I:GetLocalAngularVelocity().z\r\n\r\n  I:RequestControl(2, 1, yawResponse)\r\n  I:RequestControl(2, 4, pitchResponse)\r\n  I:RequestControl(2, 2, rollResponse)\r\nend\r\n\r\nfunction CheckTarget(I, currentTargetId)\r\n  if Vector3.Angle(I:GetTargetInfo(0, 0).Position - I:GetConstructPosition(), I:GetWeaponInfo(0).CurrentDirection) < 0.01 then\r\n    return nil\r\n  end\r\n  local candidate = nil\r\n  for warning=0, I:GetNumberOfWarnings() do\r\n    local missile = I:GetMissileWarning(warning)\r\n    if missile.Valid and currentTargetId and missile.Id == currentTargetId and missile.Position.y > minHeight and missile.Velocity.magnitude > 50 then\r\n      return missile\r\n    end\r\n    if missile.Valid and Vector3.Angle(missile.Position - I:GetConstructPosition(), I:GetWeaponInfo(0).CurrentDirection) < 0.1 then\r\n      candidate = missile\r\n    end\r\n  end\r\n  return candidate\r\nend\r\n\r\nfunction FinalGuidance(I, target)\r\n  local t = Differ.get(timeDiff)\r\n  local a, wt = Accumulator.update(accelAcc, target.Velocity, t)\r\n  local accel = a / wt\r\n  local targetLead = maxTargetLead * Mathf.Min((target.Position - I:GetConstructPosition()).magnitude / 300, 1)\r\n  if targetLead < 0.1 then targetLead = 0 end\r\n  local adjustedPos = target.Position + target.Velocity * targetLead\r\n  local adjustedVel = target.Velocity + accel * targetLead\r\n  local relPos = adjustedPos - I:GetConstructPosition()\r\n  local r = relPos.magnitude\r\n  local v = I:GetVelocityVector()\r\n  if r < altViolationZone then\r\n    return Targeting.firstOrderTargeting(relPos, adjustedVel, v.magnitude) or PP(I, target)\r\n  elseif r < maxRange then\r\n    local w = tpgWeight\r\n    if tpgWeight == -1 then\r\n      w = altViolationZone / relPos.magnitude\r\n    end\r\n    local tpgDes = Targeting.firstOrderTargeting(relPos, adjustedVel, v.magnitude)\r\n    if not tpgDes then\r\n      tpgDes = PP(I, target)\r\n    end\r\n    return Adjust(I, tpgDes * w + (1 - w) * PP(I, target))\r\n  else\r\n    I:Log(\"No targets in range\")\r\n    return Adjust(I, Idle(I))\r\n  end\r\nend\r\n\r\nfunction Adjust(I, desired)\r\n  -- Adjust steering to avoid water, space, and land\r\n  if I:GetConstructPosition().y + 100 * desired.y < altFloorWater then\r\n    desired.y = Mathf.Max(desired.y, (-I:GetConstructPosition().y  + altFloorWater) / 40)\r\n  end\r\n  if I:GetConstructPosition().y + 100 * desired.y > altCeil then\r\n    desired.y = Mathf.Min(desired.y, (-I:GetConstructPosition().y  + altCeil) / 40)\r\n  end\r\n\r\n  return desired.normalized\r\nend\r\n\r\nfunction Beamride(I, target)\r\n  local relVel = target.Velocity - I:GetVelocityVector()\r\n  local relPos = target.Position - I:GetConstructPosition()\r\n  local closingVec = -Vector3.Project(relVel, relPos) --negative because it's the missile's velocity\r\n  local closingRate = Vector3.Dot(closingVec, relPos.normalized)\r\n  local timeUntilHit = relPos.magnitude / closingRate\r\n  if timeUntilHit < 0 then return PP(I, target) end\r\n  local projection = Vector3.Project(relPos, target.Velocity)\r\n  local correction = (relPos - projection) / timeUntilHit\r\n  return projection.normalized + correction.normalized * (0.005 * correction.magnitude - 0.03 * Vector3.Dot(I:GetVelocityVector(), correction.normalized))\r\nend\r\n\r\nfunction PP(I, target)\r\n  -- point straight at the target\r\n  local relPos = target.Position - I:GetConstructPosition()\r\n\r\n  return relPos.normalized\r\nend\r\n\r\nfunction Idle(I)\r\n  -- flies in a circle at idleAlt when no target spotted\r\n  local fwv = I:GetForwardsVelocityMagnitude()\r\n  local thrust = 0.6 * I:GetDrive(0) * 3264 / Mathf.Pow(fwv, fwv*fwv/350/350)\r\n\r\n  circlePoint = I.Fleet.Flagship.CenterOfMass\r\n\r\n  local radius = I:GetConstructPosition() - circlePoint\r\n  local centripetal = Mathf.Asin(Mathf.Clamp(3.9 * fwv * fwv / idleRadius / thrust, -1, 1))\r\n  radius.y = 0\r\n  local correction = 1 * Mathf.Max(radius.magnitude - idleRadius, 0) + 2.5 * Vector3.Dot(I:GetVelocityVector(), radius.normalized)\r\n  local prediction = fwv * Differ.get(timeDiff) / idleRadius * 180 / Mathf.PI\r\n  local desired = Quaternion.AngleAxis(Mathf.Min(correction + prediction + centripetal, 90), Vector3(0, 1, 0)) * Vector3.Cross(Vector3(0, 1, 0), radius.normalized)\r\n  desired.y = 0.02 * (idleAlt - I:GetConstructPosition().y) - 0.05 * (I:GetVelocityVector().y)\r\n  desired = desired.normalized\r\n\r\n  -- missile has no lifting wings, so pitch up to account for gravity\r\n  local pitchRad = I:GetConstructPitch() * Mathf.PI/180\r\n  local gravForce = 3.9 * -I:GetGravityForAltitude(I:GetConstructPosition().y).y * Mathf.Cos(pitchRad)\r\n  local pitchGravCorrection = 180/Mathf.PI * Mathf.Asin(Mathf.Clamp(gravForce / thrust, -1, 1))\r\n  desired = Quaternion.AngleAxis(pitchGravCorrection, -Vector3.Cross(Vector3(0, 1, 0), I:GetConstructForwardVector())) * desired\r\n\r\n  return desired.normalized\r\nend\r\n\r\nfunction ResetTargetInfo()\r\n  accelAcc = Accumulator.Accumulator(accelAvgTime, accelAvgDecay)\r\n  currentTargetId = nil\r\nend\r\n\r\nfunction Accumulator.Accumulator(a,b)local c={}c.decay=b;c.window=a;c.time=0;c.weight=0;if a>0 then c.vals=LinkedList.LinkedList()c.times=LinkedList.LinkedList()end;return c end;function Accumulator.update(c,d,e)local f=Mathf.Pow(c.decay,e)if not c.value then c.value=d*e else c.value=c.value*f;c.value=c.value+d*e end;c.time=c.time+e;c.weight=c.weight*f;c.weight=c.weight+e;if c.window>0 then LinkedList.pushFront(c.vals,d)LinkedList.pushFront(c.times,e)while c.time>c.window do local g=LinkedList.popBack(c.times)c.time=c.time-g;local h=Mathf.Pow(c.decay,c.time)c.weight=c.weight-g*h;c.value=c.value-LinkedList.popBack(c.vals)*g*h end end;return c.value,c.weight end;function Accumulator.get(c)return c.value,c.weight end;function Differ.Differ(i)local j={}j.lastVal=i;j.diff=nil;return j end;function Differ.update(j,d)if j.lastVal then j.diff=d-j.lastVal;j.lastVal=d end;j.lastVal=d;return j.diff end;function Differ.get(j)return j.diff end;function LinkedList.LinkedList()local k={}k.value=nil;k.next=k;k.prev=k;return k end;function LinkedList.pushFront(l,d)local k={}k.value=d;LinkedList.connect(k,l.next)LinkedList.connect(l,k)end;function LinkedList.pushBack(l,d)local k={}k.value=d;LinkedList.connect(l.prev,k)LinkedList.connect(k,l)end;function LinkedList.popFront(l)local m=l.next.value;LinkedList.connect(l,l.next.next)return m end;function LinkedList.popBack(l)local m=l.prev.value;LinkedList.connect(l.prev.prev,l)return m end;function LinkedList.peekFront(l)return l.next.val end;function LinkedList.peekBack(l)return l.prev.val end;function LinkedList.connect(n,o)n.next=o;o.prev=n end;function LinkedList.toArray(l)local p=1;local q={}local k=l.next;while k~=l do q[p]=k.value;k=k.next end;return q end;function MathUtil.angleOnPlane(r,s,t)local u=Vector3.ProjectOnPlane(r,t)local g=Vector3.ProjectOnPlane(s,t)return Vector3.SignedAngle(u,g,t)end;function MathUtil.min(v,w)local x=nil;w=w or function(y,z)return y<z end;for ele in v do if not x or w(ele,x)then x=ele end end;return x end;function MathUtil.max(v,w)local A=nil;w=w or function(y,z)return y<z end;for ele in v do if not A or w(A,ele)then A=ele end end;return A end;function MathUtil.range(y,z,B)local C,D=y,z;local E;if not y then return end;if not z then C=0;D=y;E=C<D and 1 or-1 elseif B then E=B end;return function(F,G)local H=G+E;if H==D then return nil end;return H end,nil,C-E end;function MathUtil.angleSSS(y,z,B)if y+z<B or y+B<z or z+B<y then return nil end;local I=Mathf.Acos((z*z+B*B-y*y)/(2*z*B))*Mathf.Rad2Deg;local J,K=MathUtil.angleSAS(z,I,B)return I,J,K end;function MathUtil.sideSAS(y,K,z)local L=y*y+z*z-2*y*z*Mathf.Cos(K*Mathf.Deg2Rad)return Mathf.Sqrt(L)end;function MathUtil.angleSAS(y,K,z)local B=MathUtil.sideSAS(y,K,z)if MathUtil.isZero(B)then return nil end;local I,J;if y<z then I=MathUtil.angleLoSin(B,y,K)J=180-I-K else J=MathUtil.angleLoSin(B,z,K)I=180-J-K end;return I,J end;function MathUtil.sideSSA(y,z,I)local M=z*z-y*y;local N=-2*z*math.cos(math.rad(I))local O,P=MathUtil.solveQuadratic(1,N,M)if not P then return O,P end;if O<P then return O,P end;return P,O end;function MathUtil.angleSSA(y,z,I)local O,P=MathUtil.sideSSA(y,z,I)if not O then return nil end;local Q,R=MathUtil.angleSAS(z,I,O)if not P then return Q,R end;local S,T=MathUtil.angleSAS(z,I,P)return Q,R,S,T end;function MathUtil.sideAAS(I,J,y)local K=180-I-J;local z=MathUtil.sideLoSin(I,J,y)local B=MathUtil.sideLoSin(I,K,y)return z,B end;function MathUtil.sideLoSin(y,I,J)return y*Mathf.Sin(J*Mathf.Deg2Rad)/Mathf.Sin(I*Mathf.Deg2Rad)end;function MathUtil.angleLoSin(y,z,I)return Mathf.Asin(z*Mathf.Sin(I*Mathf.Deg2Rad)/y)*Mathf.Rad2Deg end;function MathUtil.clampCone(U,V,W)local X=Mathf.Min(W,Vector3.Angle(U,V))local Y=Vector3.Cross(U,V)return Quaternion.AngleAxis(X,Y)*U end;local Z=1e-9;function MathUtil.isZero(h)return h>-Z and h<Z end;function MathUtil.cuberoot(_)return _>0 and _^(1/3)or-math.abs(_)^(1/3)end;function MathUtil.solveQuadratic(a0,O,P)local a1,a2;local a3,a4,a5;a3=O/(2*a0)a4=P/a0;a5=a3*a3-a4;if MathUtil.isZero(a5)then a1=-a3;return a1 elseif a5<0 then return else local a6=math.sqrt(a5)a1=a6-a3;a2=-a6-a3;return a1,a2 end end;function MathUtil.solveCubic(a0,O,P,a7)local a1,a2,a8;local a9,aa;local I,J,K;local ab,a3,a4;local ac,a5;I=O/a0;J=P/a0;K=a7/a0;ab=I*I;a3=1/3*(-(1/3)*ab+J)a4=0.5*(2/27*I*ab-1/3*I*J+K)ac=a3*a3*a3;a5=a4*a4+ac;if MathUtil.isZero(a5)then if MathUtil.isZero(a4)then a1=0;a9=1 else local ad=MathUtil.cuberoot(-a4)a1=2*ad;a2=-ad;a9=2 end elseif a5<0 then local ae=1/3*math.acos(-a4/math.sqrt(-ac))local g=2*math.sqrt(-a3)a1=g*math.cos(ae)a2=-g*math.cos(ae+math.pi/3)a8=-g*math.cos(ae-math.pi/3)a9=3 else local a6=math.sqrt(a5)local ad=MathUtil.cuberoot(a6-a4)local af=-MathUtil.cuberoot(a6+a4)a1=ad+af;a9=1 end;aa=1/3*I;if a9>0 then a1=a1-aa end;if a9>1 then a2=a2-aa end;if a9>2 then a8=a8-aa end;return a1,a2,a8 end;function MathUtil.solveQuartic(a0,O,P,a7,ag)local a1,a2,a8,ah;local ai={}local aj,ad,af,aa;local I,J,K,a5;local ab,a3,a4,ak;local a9;I=O/a0;J=P/a0;K=a7/a0;a5=ag/a0;ab=I*I;a3=-0.375*ab+J;a4=0.125*ab*I-0.5*I*J+K;ak=-(3/256)*ab*ab+0.0625*ab*J-0.25*I*K+a5;if MathUtil.isZero(ak)then ai[3]=a4;ai[2]=a3;ai[1]=0;ai[0]=1;local al={MathUtil.solveCubic(ai[0],ai[1],ai[2],ai[3])}a9=#al;a1,a2,a8=al[1],al[2],al[3]else ai[3]=0.5*ak*a3-0.125*a4*a4;ai[2]=-ak;ai[1]=-0.5*a3;ai[0]=1;a1,a2,a8=MathUtil.solveCubic(ai[0],ai[1],ai[2],ai[3])aj=a1;ad=aj*aj-ak;af=2*aj-a3;if MathUtil.isZero(ad)then ad=0 elseif ad>0 then ad=math.sqrt(ad)else return end;if MathUtil.isZero(af)then af=0 elseif af>0 then af=math.sqrt(af)else return end;ai[2]=aj-ad;ai[1]=a4<0 and-af or af;ai[0]=1;do local al={MathUtil.solveQuadratic(ai[0],ai[1],ai[2])}a9=#al;a1,a2=al[1],al[2]end;ai[2]=aj+ad;ai[1]=a4<0 and af or-af;ai[0]=1;if a9==0 then local al={MathUtil.solveQuadratic(ai[0],ai[1],ai[2])}a9=a9+#al;a1,a2=al[1],al[2]end;if a9==1 then local al={MathUtil.solveQuadratic(ai[0],ai[1],ai[2])}a9=a9+#al;a2,a8=al[1],al[2]end;if a9==2 then local al={MathUtil.solveQuadratic(ai[0],ai[1],ai[2])}a9=a9+#al;a8,ah=al[1],al[2]end end;aa=0.25*I;if a9>0 then a1=a1-aa end;if a9>1 then a2=a2-aa end;if a9>2 then a8=a8-aa end;if a9>3 then ah=ah-aa end;return a1,a2,a8,ah end;function RingBuffer.RingBuffer(am)local an={}an.buf={}an.capacity=am;an.tail=1;an.head=1;return an end;function RingBuffer.isFull(an)return(an.head-an.tail)%an.capacity==1 end;function RingBuffer.isEmpty(an)return an.head==an.tail end;function RingBuffer.push(an,d)an.buf[an.tail]=d;if RingBuffer.isFull(an)then an.head=an.head%an.capacity+1 end;an.tail=an.tail%an.capacity+1 end;function RingBuffer.pop(an)if RingBuffer.isEmpty(an)then return nil end;local m=an.buf[an.head]an.buf[an.head]=nil;an.head=an.head%an.capacity+1;return m end;function Control.PID(ao,ap,aq,ar,as,at)local au={}au.kP=ao;au.kI=ap;au.kD=aq;au.Iacc=Accumulator.Accumulator(ar,as)if at and at~=0 then au.period=at end;return au end;function Control.processPID(av,aw,e)aw=av.period and(aw+av.period/2)%av.period-av.period/2 or aw;local a3=av.kP*aw;local p=av.kI*Accumulator.update(av.Iacc,aw,e)local h=av.kD*(aw-(av.lastError or aw))/e;av.lastError=aw;return a3+p+h end;function Control.FF(ai,at)local ax={}ax.coeffs=ai;ax.degree=#ai-1;if at and at~=0 then ax.period=at end;ax.derivs={}return ax end;function Control.processFF(av,ay,e)local az=0*ay;local aA=ay;local aB=ay;for p=1,av.degree+1 do aB=av.derivs[p]av.derivs[p]=aA;az=az+av.coeffs[p]*aA;if aB then local aC=aA-aB;if p==1 and av.period then aC=(aC+av.period/2)%av.period-av.period/2 end;aA=aC/e else break end end;return az end;function Nav.toLocal(aD,aE,aF)local aG=aD-aE;return Quaternion.Inverse(aF)*aG end;function Nav.toGlobal(aH,aE,aF)local aG=aF*aH;return aG+aE end;function Nav.cartToPol(aI)local ak=aI.magnitude;local aJ=Vector3.SignedAngle(Vector3.forward,aI,Vector3.up)local ae=90-Vector3.Angle(Vector3.up,aI)return Vector3(ak,aJ,ae)end;function Nav.cartToCyl(aI)local aK=Vector3(aI.x,0,aI.z)local aL=aK.magnitude;local ae=Vector3.SignedAngle(Vector3.forward,aI,Vector3.up)local aj=aI.y;return Vector3(aL,ae,aj)end;function Nav.polToCart(aI)local ak,aJ,ae=aI.x,aI.y,aI.z;local _=Mathf.Sin(aJ)*Mathf.Cos(ae)local aM=Mathf.Sin(ae)local aj=Mathf.Cos(aJ)*Mathf.Cos(ae)return ak*Vector3(_,aM,aj)end;function Nav.cylToCart(aI)local aL,ae,aN=aI.x,aI.y,aI.z;local _=aL*Mathf.Sin(ae)local aM=aN;local aj=aL*Mathf.Cos(ae)return Vector3(_,aM,aj)end;function Targeting.firstOrderTargeting(aO,aP,aQ)local aR=Vector3.Angle(-aO,aP)local aS,O,aT,P=MathUtil.angleSSA(aQ,aP.magnitude,aR)if not aS then return nil end;local aU=aT or aS;if not aU then return nil end;return(Quaternion.AngleAxis(aU,Vector3.Cross(aO,aP))*aO).normalized end;function Targeting.secondOrderTargeting(aO,aV,aW,aQ,aX,aY)local g=Targeting.secondOrderTargetingTime(aO,aV,aW,aQ,aX/aQ,aY/aQ)if g and g>0 then return(aO/g+aV-0.5*aW*g).normalized end;return nil end;function Targeting.secondOrderTargetingTime(aO,aV,aW,aQ,aZ,a_)local y=0.25*aW.sqrMagnitude;local z=Vector3.Dot(aV,aW)local B=aV.sqrMagnitude-aQ*aQ+Vector3.Dot(aO,aW)local h=2*Vector3.Dot(aO,aV)local aw=aO.sqrMagnitude;local b0={MathUtil.solveQuartic(y,z,B,h,aw)}local g=nil;for p=1,4 do if b0[p]and b0[p]>aZ and b0[p]<a_ then if not g or g and b0[p]<g then g=b0[p]end end end;return g end;function Targeting.AIPPN(b1,aO,b2,aP,b3)local aV=aP-b2;local b4=Vector3.Dot(-aV,aO.normalized)if b4<=0 then b4=10 end;local b5=aO.magnitude/b4;local b6=Vector3.Cross(aO,aV)/aO.sqrMagnitude;local b7=Vector3.Cross(aO,b3)/aO.sqrMagnitude*b5/2;local b8=b6+b7;local b9=Vector3.Cross(b8,aO.normalized)local ba=Vector3.ProjectOnPlane(b9,b2).normalized;local bb=b1*b2.magnitude*b8.magnitude;return bb*ba end;function Targeting.ATPN(b1,aO,b2,aP,b3)local aV=aP-b2;local b4=-Vector3.Dot(aV,aO.normalized)if b4<=0 then b4=10 end;local b6=Vector3.Cross(aO,aV)/aO.sqrMagnitude;local b9=Vector3.Cross(b6,aO.normalized)local bc=Vector3.ProjectOnPlane(b3,aO)return b1*b4*b9+0.5*b1*b3 end;function Targeting.accelToDirection(bd,be,e)local bf=Vector3.Cross(bd,be)/bd.sqrMagnitude*e*Mathf.Rad2Deg;return Quaternion.AngleAxis(bf.magnitude,bf)*bd end;function BlockUtil.getWeaponsByName(bg,bh,bi,bj)if DEBUG then bg:Log(\"searching for \"..bh)end;local bk=bg:GetAllSubConstructs()local bl={}bi=bi or-1;local B=bi;if not bj or bj==0 or bj==2 then for p=0,bg:GetWeaponCount()-1 do if B==0 then break end;if bg:GetWeaponBlockInfo(p).CustomName==bh then table.insert(bl,{subIdx=nil,wpnIdx=p})if DEBUG then bg:Log(\"found weapon \"..bh..\" on hull, type \"..bg:GetWeaponInfo(p).WeaponType)end;B=B-1 end end end;if not bj or bj==1 or bj==2 then for bm=1,#bk do local aa=bk[bm]for p=0,bg:GetWeaponCountOnSubConstruct(aa)-1 do if B==0 then break end;if bg:GetWeaponBlockInfoOnSubConstruct(aa,p).CustomName==bh then table.insert(bl,{subIdx=aa,wpnIdx=p})if DEBUG then bg:Log(\"found weapon \"..bh..\" on subobj \"..aa..\", type \"..bg:GetWeaponInfo(p).WeaponType)end;B=B-1 end end end end;if DEBUG then bg:Log(\"weapon count: \"..#bl)end;return bl end;function BlockUtil.getSubConstructsByName(bg,bh,bi)if DEBUG then bg:Log(\"searching for \"..bh)end;local bk=bg:GetAllSubConstructs()local bn={}bi=bi or-1;local B=bi;for bm=1,#bk do local aa=bk[bm]if B==0 then break end;if bg:GetSubConstructInfo(aa).CustomName==bh then table.insert(bn,aa)if DEBUG then bg:Log(\"found subobj \"..bh)end;B=B-1 end end;if DEBUG then bg:Log(\"subobj count: \"..#bn)end;return bn end;function BlockUtil.getBlocksByName(bg,bh,bo,bi)if DEBUG then bg:Log(\"searching for \"..bh)end;local bp={}bi=bi or-1;local B=bi;for bm=0,bg:Component_GetCount(bo)-1 do if B==0 then break end;if bg:Component_GetBlockInfo(bo,bm).CustomName==bh then table.insert(bp,bm)if DEBUG then bg:Log(\"found component \"..bh)end;B=B-1 end end;if DEBUG then bg:Log(\"component count: \"..#bp)end;return bp end;function BlockUtil.getWeaponInfo(bg,bq)local br;if bq.subIdx then br=bg:GetWeaponInfoOnSubConstruct(bq.subIdx,bq.wpnIdx)else br=bg:GetWeaponInfo(bq.wpnIdx)end;return br end;function BlockUtil.aimWeapon(bg,bq,bs,bt)if bq.subIdx then bg:AimWeaponInDirectionOnSubConstruct(bq.subIdx,bq.wpnIdx,bs.x,bs.y,bs.z,bt)else bg:AimWeaponInDirection(bq.wpnIdx,bs.x,bs.y,bs.z,bt)end end;function BlockUtil.fireWeapon(bg,bq,bt)if bq.subIdx then bg:FireWeaponOnSubConstruct(bq.subIdx,bq.wpnIdx,bt)else bg:FireWeapon(bq.wpnIdx,bt)end end;function Combat.pickTarget(bg,bu,bv)bv=bv or function(F,bw)return bw.Priority end;local ay,bx;for p in MathUtil.range(bg:GetNumberOfTargets(bu))do local bw=bg:GetTargetInfo(bu,p)local by=bv(bg,bw)if not ay or by>bx then ay=bw;bx=by end end;return ay end;function CheckConstraints(bg,bz,bA,bB)local bC;if bB then bC=bg:GetWeaponConstraintsOnSubConstruct(bB,bA)else bC=bg:GetWeaponConstraints(bA)end;local bD=bg:GetConstructForwardVEctor()local bE=bg:GetConstructUpVector()local bF=Quaternion.LookRotation(bD,bE)bz=Quaternion.Inverse(bF)*bz;if bC.InParentConstructSpace and bB then local bG=bg:GetSubConstructInfo(bB).localRotation;bz=Quaternion.inverse(bG)*bz end;local bH=MathUtil.angleOnPlane(Vector3.forward,bz,Vector3.up)local bI=bz;bI.z=0;local bJ=Mathf.Atan2(bz.z,bI.magnitude)local bK=bH>bC.MinAzimuth and bH<bC.MaxAzimuth;local bL=bJ>bC.MinElevation and bJ<bC.MaxElevation;if bC.FlipAzimuth then bK=not bK end;if bK and bL then return true end;bH=bH+180;ele=180-ele;if ele>180 then ele=ele-360 end;if ele<-180 then ele=ele+360 end;bK=bH>bC.MinAzimuth and bH<bC.MaxAzimuth;bL=bJ>bC.MinElevation and bJ<bC.MaxElevation;if bC.FlipAzimuth then bK=not bK end;if bK and bL then return true end;return false end\r\n"],"BlockStringDataIds":[150],"GameVersion":"3.2.9.7","PersistentSubObjectIndex":29,"PersistentBlockIndex":171,"AuthorDetails":{"Valid":true,"ForeignBlocks":0,"CreatorId":"051780ed-f58a-41a6-b60f-84fb260c1b22","ObjectId":"ce7c7310-16d6-431b-9340-de70f11de25e","CreatorReadableName":"DreekFire","HashV1":"43488cf16db2c12d7c9a62d3ae84e2ff"},"BlockCount":21}}