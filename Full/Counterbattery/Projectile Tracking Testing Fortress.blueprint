{"FileModelVersion":{"Major":1,"Minor":0},"Name":"Projectile Tracking Testing Fortress","Version":14,"SavedTotalBlockCount":815,"SavedMaterialCost":54904.0,"ContainedMaterialCost":372.596161,"ItemDictionary":{"1134":"9411e401-27da-4546-b805-3334f200f055","299":"f29b1372-f4f3-4305-aa85-5fe214361fb7","1132":"8f9dbf41-6c2d-4e7b-855d-b2432c6942a2","300":"26a604f0-071c-49ca-8a0e-e1d9c959b1c5","321":"3ed4d2a4-62ce-4807-b516-6da685804e1e","191":"438b4494-6746-4223-93a1-3a75b08bd5b6","296":"edd65760-896f-4f6a-ba8c-eb2b072635f4","301":"9d2ff3d6-abc2-4378-b47c-cad42d4af1bc","344":"2c557c38-4136-436a-bae2-c5cd1102690c","228":"56c27d46-39b3-4ac1-b4f7-71c118d8dde9","258":"d661f0e7-7f81-4227-80dd-f93aed873630","1087":"e62413c3-e841-4eda-9e2a-ceaec75e8b64","234":"c8fe583a-357b-4fa6-86f1-fc2de639c909","279":"e8d04f75-a134-452e-a04a-af5172d65040","596":"382a7650-2231-4867-96e4-8d97242a4741","1213":"395179c1-37a0-4250-851b-5bc19fd601b6","1212":"049b9d0c-1cb3-4511-be7f-9fad6e0a607e","488":"2e715d3f-349f-41e1-bd89-7f685939d5aa","490":"20100af6-ccd1-41ff-b7b0-5d2f6bb99f85","347":"e6bb2b09-daee-432d-9aff-45fc63d24fca","349":"a56e0dcf-94e4-48a0-b8b9-5e33e0ab69cf","330":"1725c9ed-29fd-438d-97f6-8f645a1865d4","348":"4b334c3f-aafd-440c-9c1f-02a98fd18ab5","334":"10a165d1-1333-4c57-a942-b857542c4b45","309":"c68d0ed7-66d1-42cd-974e-01aa0f36c847","336":"a6edccd7-3ec8-419c-9405-703e8b4bdc8b","311":"62e2b663-c26f-461e-ae26-43068010f993","326":"1bb2d71d-cd5f-4a23-844b-8005dec7bd5c","339":"3e0a0bd7-7805-4e8f-836e-0cbcfee512af","567":"5031a9db-aa48-4903-9b16-75a54f5959ce","557":"db2a5655-6b32-4877-8285-40c6ddc9ba3c","556":"9c09eee2-e4bd-42ea-aaec-43a6d1451db3","553":"b6ac5f2e-907e-4926-88c0-355d30c6b7a5","562":"57c4c674-9c66-4ab7-9067-81477824785d","561":"ef2e81c1-d06d-474f-b12c-14de1702db1b","590":"45ce64f5-86ca-425a-8074-7603cdfc1d4a","565":"139d4b6a-2b6b-4bfa-8d00-1bc8e69923fd","494":"d3924bae-be5a-43a0-be19-64fc7c8d6059","259":"9413049d-a4f7-4c1c-8b8a-d2f1f4c18e53","915":"d5016f16-6431-4e8f-b0cc-5f0f400b151a","936":"91cca4a9-a40f-43eb-9ba5-34c738b03d1f","923":"6ebe5e2b-ef9a-4849-b234-131b25579adf","922":"4b2109f7-abfc-46b7-b752-f9423b6f2e35","935":"6209370e-abeb-4ec1-b523-dc21ea33fe0c","929":"a160804b-15cc-46e2-8ffb-401c2aa01de6","937":"542cacd4-c366-4a76-8d01-4ace6c5ce619","924":"33b65ccc-58a0-487d-8b68-a997a71b0bfe","910":"3bff8428-7481-4847-b00e-f0e49233b86d","926":"99a71734-3128-4535-bb9c-f69de5277f49","256":"5d8870cd-d401-4b52-a3dc-641c02b3b31f","257":"4f87eff7-616b-4663-8f11-cd7a7ddd3649","914":"043e9b00-4a2f-41b8-bf2f-4aaa4442f138","917":"515ee20d-20d8-4195-bea5-213e6f1fd929","913":"267248a3-baaa-4653-83b3-ce478d600b17","934":"e0f9e669-4748-4cde-be95-58e47e094253","911":"819ef76e-1023-4f06-bfb1-96cd3e58ba88","919":"4c24445d-a29b-446e-b03f-29e570e9d47d","916":"01a87958-93cf-4efa-857f-10913b0573d9","928":"da59d582-9254-4091-988e-b670dcabe84a","551":"fb1fb4c7-78e8-47e7-8ff1-34a4afcd10c7","1133":"649f2aec-6f59-4157-ac01-0122ce2e6dad","592":"74c982f4-305f-411e-a8b4-d193315ab3bc","608":"c5cec892-2e43-4905-9d28-44fc8ecb5cc7","555":"7dc67bed-fd0f-4145-9525-5840bbcc4822","549":"575187d2-ff5c-4d42-9937-0206cffbd883","550":"9aa6b3c3-2569-473e-9d28-2b2cb17bc7a3","609":"213026bc-fd7a-44e6-b543-a31c219aaef0","476":"a3d914e9-697d-425f-abda-a6b21b4de952"},"Blueprint":{"ContainedMaterialCost":372.596161,"CSI":[0.0,0.0,-1.0,0.0,-1.0,0.0,0.0,10369.775390625,0.012536433525383472,0.0,0.0,0.0,0.0,63418.967136059524,20.58586311340332,1.0,1.0,0.0,1.0,3.0,19.464065551757813,-1.0,0.0,136500.0,1.0,1.0,135000.0,0.0,0.0,0.0,306.64999389648438,0.0,0.1,0.1,1.0,1.0,3.0,-1.0,0.0,-1.0,20.58586311340332,-1.0,1.0,0.0,-1.0,0.0,0.0,-1.0,134999.995984662,135000.0,0.0,780.0,-1.0,2322.0,0.0,-1.0,108.0,0.0,500.0,-1.0,12.0,0.0,0.0,0.0,12.870475769042969,0.0,0.0,0.0,0.0,0.12485428899526596,0.0,0.0,0.0,0.0,1.0,1.0,-1.0,-1.0,-1.0,-1.0],"COL":["0.011764,0,0,0","1,0,0,0.5","0,1,0,0.5","0,0,1,0.5","0.1,0.1,0.1,0.5","0.3,0.3,0.3,0.5","0.5,0.5,0.5,0.5","1,1,1,0.1","1,1,1,0.5","1,1,1,0.99","1,0.921568,0.015686,0.99","0,1,1,0.99","1,0,1,0.99","0.532304,0.92424,0.976154,0.482858","0.624097,0.172987,0.071987,0.558838","0.589444,0.995137,0.300367,0.102439","0.2717,0.865858,0.367956,0.486776","0.639902,0.591997,0.036744,0.032933","0.775841,0.906789,0.151626,0.255117","0.791803,0.770037,0.042215,0.984062","0.691124,0.827073,0.992751,0.725039","0.308429,0.229756,0.46043,0.078918","0.983768,0.814959,0.334567,0.270744","0.611877,0.542545,0.044901,0.943315","0.88138,0.579203,0.104262,0.074014","0.891141,0.224628,0.060396,0.025437","0.345402,0.253313,0.07177,0.618634","0,0,0,0","0.345098,0.3,0.8,0.6","0.015686,1,1,0.989999","0.984313,1,1,1","0,0,0,1"],"SCs":[{"ContainedMaterialCost":0.0,"CSI":[-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0],"COL":null,"SCs":[],"BLP":["0,0,0","0,1,0","0,1,-1","0,0,-1","0,0,-2","1,0,-2","-1,0,-2","1,0,0","-1,0,0","1,0,1","-1,0,1","1,0,2","-1,0,2","1,0,3","-1,0,3","1,0,4","-1,0,4","1,0,-1","-1,0,-1"],"BLR":[0,16,16,16,16,16,18,16,18,16,18,16,18,16,18,16,18,16,18],"BP1":null,"BP2":null,"BCI":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"BEI":null,"BlockData":"AAAAKgAAACgAAwAAAAAAAAEAAAAAAAACAAAAABIAdiYAAAAZAEIYAAAAGQBdGwEAABkAAAAEAAAWwwEABAAAFkMGAAEBAQAEzczMPQAABCgAAAABAAVsYXNlcgUAADEAAAAkAAwYAAAAAADsFwAAAAAAAQAAAAAAAAIAAAAAAAB2JgAAAAcAQhgAAAAHAF0bAQAAFQABAAQK1yM8AAAEQizRRwIABAbgUEsAAAQBAAAAAQAFbGFzZXIGAAAxAAAAJAAMGAAAAAAA7BcAAAAAAAEAAAAAAAACAAAAAAAAdiYAAAAHAEIYAAAABwBdGwEAABUAAQAECtcjPAAABClGDkgCAASPYFBLAAAEAgAAAAEABWxhc2Vy","VehicleData":"RykBAAAAAAAVAAAAAAAAAAAAAAAAcycAAAAAAGQAAAAAAABXLgAAAAAAAAcAAAAAAAAAAAAAAADwWwoBAAAAAA4AAAAAAA8nAAAAAADQBwAAAAAAn3EEAAAAAAAOAAAAAAAPJwAAAAAAoIYBAAAAAA==","designChanged":false,"blueprintVersion":0,"blueprintName":"Two Axis Turret","SerialisedInfo":{"JsonDictionary":{},"IsEmpty":true},"Name":null,"ItemNumber":609,"LocalPosition":"0,5,11","LocalRotation":"0,0,0,-0.999999","ForceId":0,"TotalBlockCount":19,"MaxCords":"1,1,4","MinCords":"-1,0,-2","BlockIds":[608,565,556,556,556,555,555,549,549,549,549,549,549,549,549,549,549,550,550],"BlockState":"=0,19","AliveCount":19,"BlockStringData":[],"BlockStringDataIds":[],"GameVersion":"3.6.0.8","PersistentSubObjectIndex":7,"PersistentBlockIndex":-1,"AuthorDetails":{"Valid":true,"ForeignBlocks":0,"CreatorId":"051780ed-f58a-41a6-b60f-84fb260c1b22","ObjectId":"fe5bb7da-f3e9-4d92-acd2-f7002e9544b0","CreatorReadableName":"DreekFire","HashV1":"a5598512ea30c7b3f81210225838b965"},"BlockCount":19},{"ContainedMaterialCost":0.0,"CSI":[-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0],"COL":null,"SCs":[],"BLP":["0,0,0","0,1,0"],"BLR":[0,0],"BP1":null,"BP2":null,"BCI":[0,0],"BEI":null,"BlockData":"AAAAKgAAABwAAwAAAAAAAAEAAAAAAAACAAAAAAAAdiYAAAAHAEIYAAAABwBdGwEAAAcAAQAECtcjPAAABFUAAAABAAtjaGVja1R1cnJldAEAACMAAAA+AAEAAAAAAAACAAAAAB0AAwAAAAAvAF0AAAAANwBdGwEAADcApAAIAAAAAAAAaUClAAgAAAAAAMCiQJgABAUAAAALAAgAAAAAAADwP5gABLAAAAAFAAVjaGVjawAABFYAAAA=","VehicleData":"RykBAAAAAAAVAAAAAAAAAAAAAAAAcycAAAAAAGQAAAAAAABXLgAAAAAAAAcAAAAAAAAAAAAAAADwWwoBAAAAAA4AAAAAAA8nAAAAAADQBwAAAAAAn3EEAAAAAAAOAAAAAAAPJwAAAAAAoIYBAAAAAA==","designChanged":false,"blueprintVersion":0,"blueprintName":"Two Axis Turret","SerialisedInfo":{"JsonDictionary":{},"IsEmpty":true},"Name":null,"ItemNumber":609,"LocalPosition":"0,5,12","LocalRotation":"0,0,0,1","ForceId":0,"TotalBlockCount":2,"MaxCords":"0,1,0","MinCords":"0,0,0","BlockIds":[608,476],"BlockState":"00","AliveCount":2,"BlockStringData":[],"BlockStringDataIds":[],"GameVersion":"3.6.0.8","PersistentSubObjectIndex":8,"PersistentBlockIndex":-1,"AuthorDetails":{"Valid":true,"ForeignBlocks":0,"CreatorId":"051780ed-f58a-41a6-b60f-84fb260c1b22","ObjectId":"fe5bb7da-f3e9-4d92-acd2-f7002e9544b0","CreatorReadableName":"DreekFire","HashV1":"a5598512ea30c7b3f81210225838b965"},"BlockCount":2}],"BLP":["0,1,-1","-1,1,-1","1,1,-1","-2,1,-1","2,1,-1","-3,1,-1","3,1,-1","-4,1,-1","4,1,-1","-5,1,-1","5,1,-1","-6,1,-1","6,1,-1","-7,1,-1","7,1,-1","-8,1,-1","8,1,-1","-9,1,-1","9,1,-1","-10,1,-1","10,1,-1","-11,1,-1","11,1,-1","-12,1,-1","12,1,-1","-13,1,-1","13,1,-1","-14,1,-1","14,1,-1","-15,1,-1","15,1,-1","-15,1,-5","15,1,-5","-15,1,-9","15,1,-9","-15,1,-13","15,1,-13","-15,1,-17","15,1,-17","-14,1,-17","14,1,-17","-13,1,-17","13,1,-17","-12,1,-17","12,1,-17","-11,1,-17","11,1,-17","-10,1,-17","10,1,-17","-9,1,-17","9,1,-17","-8,1,-17","8,1,-17","-7,1,-17","7,1,-17","-6,1,-17","6,1,-17","-5,1,-17","5,1,-17","-4,1,-17","4,1,-17","-3,1,-17","3,1,-17","-2,1,-17","2,1,-17","-1,1,-17","1,1,-17","0,1,-17","-15,1,3","15,1,3","-15,1,7","15,1,7","-15,1,11","15,1,11","-15,1,15","15,1,15","-14,1,15","14,1,15","-13,1,15","13,1,15","-12,1,15","12,1,15","-11,1,15","11,1,15","-10,1,15","10,1,15","-9,1,15","9,1,15","-8,1,15","8,1,15","-7,1,15","7,1,15","-6,1,15","6,1,15","-5,1,15","5,1,15","-4,1,15","4,1,15","-3,1,15","3,1,15","-2,1,15","2,1,15","-1,1,15","1,1,15","0,1,15","1,1,11","2,1,11","0,1,11","3,1,11","-1,1,11","4,1,11","-2,1,11","1,1,7","5,1,11","-3,1,11","2,1,7","0,1,7","6,1,11","-4,1,11","3,1,7","-1,1,7","7,1,11","-5,1,11","4,1,7","-2,1,7","8,1,11","-6,1,11","1,1,3","5,1,7","-3,1,7","9,1,11","-7,1,11","2,1,3","0,1,3","6,1,7","-4,1,7","10,1,11","-8,1,11","3,1,3","-1,1,3","7,1,7","-5,1,7","11,1,11","-9,1,11","4,1,3","-2,1,3","8,1,7","-6,1,7","12,1,11","-10,1,11","5,1,3","-3,1,3","9,1,7","-7,1,7","13,1,11","-11,1,11","6,1,3","-4,1,3","10,1,7","-8,1,7","14,1,11","-12,1,11","7,1,3","-5,1,3","11,1,7","-9,1,7","-13,1,11","8,1,3","-6,1,3","12,1,7","-10,1,7","-14,1,11","9,1,3","-7,1,3","13,1,7","-11,1,7","10,1,3","-8,1,3","14,1,7","-12,1,7","11,1,3","-9,1,3","-13,1,7","12,1,3","-10,1,3","-14,1,7","13,1,3","-11,1,3","14,1,3","-12,1,3","-13,1,3","-14,1,3","1,1,-5","2,1,-5","0,1,-5","3,1,-5","-1,1,-5","4,1,-5","-2,1,-5","1,1,-9","5,1,-5","-3,1,-5","2,1,-9","0,1,-9","6,1,-5","-4,1,-5","3,1,-9","-1,1,-9","7,1,-5","-5,1,-5","4,1,-9","-2,1,-9","8,1,-5","-6,1,-5","1,1,-13","5,1,-9","-3,1,-9","9,1,-5","-7,1,-5","2,1,-13","0,1,-13","6,1,-9","-4,1,-9","10,1,-5","-8,1,-5","3,1,-13","-1,1,-13","7,1,-9","-5,1,-9","11,1,-5","-9,1,-5","4,1,-13","-2,1,-13","8,1,-9","-6,1,-9","12,1,-5","-10,1,-5","5,1,-13","-3,1,-13","9,1,-9","-7,1,-9","13,1,-5","-11,1,-5","6,1,-13","-4,1,-13","10,1,-9","-8,1,-9","14,1,-5","-12,1,-5","7,1,-13","-5,1,-13","11,1,-9","-9,1,-9","-13,1,-5","8,1,-13","-6,1,-13","12,1,-9","-10,1,-9","-14,1,-5","9,1,-13","-7,1,-13","13,1,-9","-11,1,-9","10,1,-13","-8,1,-13","14,1,-9","-12,1,-9","11,1,-13","-9,1,-13","-13,1,-9","12,1,-13","-10,1,-13","-14,1,-9","13,1,-13","-11,1,-13","14,1,-13","-12,1,-13","-13,1,-13","-14,1,-13","0,2,-17","0,8,-17","0,6,-17","0,2,-16","0,2,-15","0,2,-14","0,2,-13","0,2,-12","0,3,-12","0,3,-13","0,3,-14","1,2,-16","1,2,-15","1,2,-14","1,2,-13","1,2,-12","-1,2,-12","-1,2,-13","-1,2,-14","-1,2,-15","-1,2,-16","-2,3,-16","-2,3,-15","-2,3,-14","-2,3,-13","-2,3,-12","2,3,-12","2,3,-13","2,3,-14","2,3,-15","2,3,-16","1,3,-12","1,3,-13","1,3,-14","1,3,-15","1,3,-16","-1,3,-16","-1,3,-15","-1,3,-14","-1,3,-13","-1,3,-12","-2,2,-16","-2,2,-15","-2,2,-14","-2,2,-13","-2,2,-12","-2,2,-11","2,2,-11","2,2,-12","2,2,-13","2,2,-14","2,2,-15","2,2,-16","4,2,-13","-4,2,-13","2,3,-11","1,3,-11","0,3,-11","-1,3,-11","-2,3,-11","0,2,-11","-1,2,-11","1,2,-11","0,4,-15","0,4,-12","-2,4,-16","2,4,-16","-2,4,-14","2,4,-14","-2,4,-12","2,4,-12","0,3,-16","7,2,-12","-7,2,-12","7,2,-15","-7,2,-15","-15,0,-17","15,0,-17","-14,0,-17","14,0,-17","-14,0,-16","14,0,-16","-15,0,-16","15,0,-16","-14,0,18","14,0,18","-15,0,18","15,0,18","-14,0,17","14,0,17","-15,0,17","15,0,17","-1,5,-16","1,5,-16","-5,5,-16","5,5,-16","-5,5,-15","5,5,-15","-5,5,-14","5,5,-14","-5,5,-13","5,5,-13","-5,5,-12","5,5,-12","-5,5,-11","5,5,-11","-1,5,-11","1,5,-11","-1,5,-12","1,5,-12","-1,5,-13","1,5,-13","-1,5,-14","1,5,-14","-1,5,-15","1,5,-15","0,5,-16","0,5,-13","0,2,-10","-1,2,-10","1,2,-10","-2,2,-10","2,2,-10","-3,2,-10","3,2,-10","-4,2,-10","4,2,-10","-5,2,-10","5,2,-10","-6,2,-10","6,2,-10","-7,2,-10","7,2,-10","-8,2,-10","8,2,-10","-9,2,-10","9,2,-10","-9,2,-11","9,2,-11","-9,2,-12","9,2,-12","-9,2,-13","9,2,-13","-9,2,-14","9,2,-14","-9,2,-15","9,2,-15","-9,2,-16","9,2,-16","-9,2,-17","9,2,-17","-8,2,-17","8,2,-17","-7,2,-17","7,2,-17","-6,2,-17","6,2,-17","-5,2,-17","5,2,-17","-4,2,-17","4,2,-17","-3,2,-17","3,2,-17","-2,2,-17","2,2,-17","-1,2,-17","1,2,-17","0,2,-9","0,2,-7","0,8,-18","0,3,-15","0,9,-17","-10,5,-17","10,5,-17","-10,5,-10","10,5,-10","-9,5,-9","9,5,-9","-9,5,-18","9,5,-18","-15,2,-17","15,2,-17","0,9,-18","-1,9,-17","1,9,-17","0,10,-17","1,8,-17","-1,8,-17","0,9,-16","0,8,-16","0,3,11","1,3,10","-1,3,10","-1,3,11","1,3,11","-1,3,9","-1,3,8","-1,3,7","-1,3,6","-1,3,5","1,3,5","1,3,6","1,3,7","1,3,8","1,3,9","1,4,9","-1,4,8","1,4,7","1,4,5","-1,2,6","-1,2,8","1,2,9","1,2,7","1,2,5","-1,3,4","1,3,4","-1,4,4","-1,2,4","0,3,8","0,3,5","-2,3,5","-2,3,7","-2,3,9","2,3,8","2,3,6","2,3,4","1,4,4","1,4,8","-1,4,9","-1,4,6","1,4,6","-1,4,7","-1,4,5","-2,3,4","-2,3,6","-2,3,8","-1,2,9","-1,2,7","-1,2,5","1,2,4","1,2,6","1,2,8","2,3,9","2,3,7","2,3,5","1,3,3","-1,3,2","1,3,1","-1,3,0","-1,3,1","1,3,2","-1,3,3","-2,3,3","-2,3,1","2,3,2","2,3,0","1,3,0","1,4,0","1,4,2","1,2,0","1,2,2","-1,2,1","-1,2,3","-1,4,1","-1,4,3","0,2,11","0,4,10","0,2,-8","-2,3,-6","-2,3,-5","-2,3,-4","-2,3,-3","-2,3,-2","-2,3,-1","-1,2,-6","-1,2,-5","-1,2,-4","-1,2,-3","-1,2,-2","-1,2,-1","-1,3,-6","-1,3,-5","-1,3,-4","-1,3,-3","-1,3,-2","-1,3,-1","-1,4,-6","-1,4,-5","-1,4,-4","-1,4,-3","-1,4,-2","-1,4,-1","0,3,-5","0,3,-2","1,2,-6","1,2,-5","1,2,-4","1,2,-3","1,2,-2","1,2,-1","1,3,-6","1,3,-5","1,3,-4","1,3,-3","1,3,-2","1,3,-1","1,4,-6","1,4,-5","1,4,-4","1,4,-3","1,4,-2","1,4,-1","2,3,-6","2,3,-5","2,3,-4","2,3,-3","2,3,-2","2,3,-1","-2,-4,-17","-2,-4,-13","-2,-4,-9","-2,-3,-16","-2,-3,-14","-2,-3,-13","-2,-3,-11","-2,-3,-9","-2,-2,-17","-2,-2,-16","-2,-2,-15","-2,-2,-14","-2,-2,-13","-2,-2,-12","-2,-2,-11","-2,-2,-10","-2,-2,-9","-2,-1,-16","-2,-1,-14","-2,-1,-13","-2,-1,-11","-2,-1,-9","-2,0,-17","-2,0,-16","-2,0,-15","-2,0,-13","-2,0,-9","-1,-4,-16","-1,-4,-14","-1,-4,-13","-1,-4,-11","-1,-4,-9","-1,-3,-17","-1,-3,-16","-1,-3,-15","-1,-3,-14","-1,-3,-12","-1,-3,-11","-1,-3,-10","-1,-2,-17","-1,-2,-16","-1,-2,-15","-1,-2,-14","-1,-2,-13","-1,-2,-12","-1,-2,-11","-1,-2,-10","-1,-2,-9","-1,-1,-17","-1,-1,-16","-1,-1,-15","-1,-1,-14","-1,-1,-12","-1,-1,-11","-1,-1,-10","-1,0,-16","-1,0,-14","-1,0,-13","-1,0,-11","0,-4,-17","0,-4,-16","0,-4,-15","0,-4,-14","0,-4,-13","0,-4,-12","0,-4,-11","0,-4,-10","0,-4,-9","0,-3,-17","0,-3,-16","0,-3,-15","0,-3,-14","0,-3,-13","0,-3,-12","0,-3,-11","0,-3,-10","0,-3,-9","0,-2,-17","0,-2,-16","0,-2,-15","0,-2,-14","0,-2,-13","0,-2,-12","0,-2,-11","0,-2,-10","0,-2,-9","0,-1,-17","0,-1,-16","0,-1,-15","0,-1,-14","0,-1,-13","0,-1,-12","0,-1,-11","0,-1,-10","0,-1,-9","0,0,-17","0,0,-16","0,0,-15","0,0,-14","0,0,-13","0,0,-12","0,0,-11","0,0,-10","0,0,-9","1,-4,-16","1,-4,-14","1,-4,-13","1,-4,-11","1,-3,-17","1,-3,-16","1,-3,-15","1,-3,-14","1,-3,-12","1,-3,-11","1,-3,-10","1,-2,-17","1,-2,-16","1,-2,-15","1,-2,-14","1,-2,-13","1,-2,-12","1,-2,-11","1,-2,-10","1,-2,-9","1,-1,-17","1,-1,-16","1,-1,-15","1,-1,-14","1,-1,-12","1,-1,-11","1,-1,-10","1,0,-16","1,0,-14","1,0,-13","1,0,-11","1,0,-9","2,-4,-17","2,-4,-16","2,-4,-15","2,-4,-13","2,-4,-9","2,-3,-16","2,-3,-14","2,-3,-13","2,-3,-11","2,-3,-9","2,-2,-17","2,-2,-16","2,-2,-15","2,-2,-14","2,-2,-13","2,-2,-12","2,-2,-11","2,-2,-10","2,-2,-9","2,-1,-16","2,-1,-14","2,-1,-13","2,-1,-11","2,-1,-9","2,0,-17","2,0,-13","2,0,-9","-3,-4,-17","3,-4,-17","-3,-4,-9","3,-4,-9","-3,-4,-12","3,-4,-12","-3,-4,-14","3,-4,-14","-3,0,-17","3,0,-17","-3,0,-12","3,0,-12","1,3,-9","-1,3,-9","1,3,-8","-1,3,-8","1,3,-7","-1,3,-7","0,6,-10","-2,6,-10","2,6,-10","-4,6,-10","4,6,-10","-4,6,-11","4,6,-11","-2,6,-11","2,6,-11","0,6,-11","0,7,-11","-2,7,-11","2,7,-11","-4,7,-11","4,7,-11","0,2,12"],"BLR":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,10,0,0,0,0,0,6,6,6,23,23,23,23,23,20,20,20,20,20,0,0,0,0,0,0,0,0,0,0,22,22,22,22,22,21,21,21,21,21,8,8,8,8,8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,0,0,9,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,9,11,0,0,6,2,0,21,20,21,20,16,18,19,17,11,9,10,11,9,1,16,18,20,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,8,8,8,8,8,0,0,4,8,3,1,22,22,22,21,21,21,5,5,5,4,5,5,5,1,1,1,11,11,11,11,11,11,15,15,15,0,0,0,0,0,0,0,20,20,21,21,0,5,5,11,11,11,11,5,5,11,0,0,1,22,1,22,1,22,8,11,8,11,8,11,0,0,0,0,0,0,4,5,4,5,4,5,1,3,11,8,11,8,11,8,0,0,0,0,0,0,5,4,5,4,5,4,21,15,21,15,21,15,0,0,13,22,19,18,20,7,1,13,9,20,22,5,15,9,1,16,19,18,20,1,0,7,0,0,1,10,14,12,8,13,22,12,18,18,12,14,12,6,18,18,17,12,18,2,18,2,22,0,18,18,2,2,2,3,2,0,4,9,6,8,12,10,1,8,3,15,6,10,12,12,16,14,4,14,19,0,0,0,0,0,0,0,0,18,10,6,0,12,18,2,9,2,17,7,10,15,10,6,15,7,13,1,0,14,12,8,22,12,16,16,12,14,12,6,18,16,19,0,17,2,17,14,22,0,16,16,2,2,2,6,2,0,4,20,0,9,12,12,15,18,17,16,21,1,15,23,11,21,16,11,15,7,8,23,17,16,21,8,0,0,5,10,10,10,10,10,10,10,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,18,16,18,16,0,0,0,0,0,10],"BP1":null,"BP2":null,"BCI":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"BEI":null,"BlockData":"GgEAMQAAAOcBDycAAAAAAITNAAAANAAAAAAAAOoAAQAAAAC3AYXNAAAA4AGGzQAAAOABXRsBAADgAQAAEPEMwKeAVyxGlpVKU+OXrYQBAAQAAAAAAgAQ9+OXZTLF2EKTl9xcvFBUHgMABAEAAAAAAAQAAAAAAgAEAQAAANwABM3MTD3dAAQAAHpD3gAEmpmZPkABBM3MTD1BAQQAAHpDQgEEmpmZPqQBBM3MTD2lAQQAAHpDpgEEmpmZPggCBM3MTD0JAgQAAHpDCgIEmpmZPmwCBM3MTD1tAgQAAHpDbgIEmpmZPtACBM3MTD3RAgQAAHpD0gIEmpmZPtAHBAMAAADRBwQAAPBB0gcEAACgQdMHBAAAyELUBwQAAEhC1QcEAAAgQW4AYDEvRGlzdGFuY2UqKEFsdGl0dWRlPjEpKihDbG9zaW5nVmVsb2NpdHk+MjAwKSooRGlzdGFuY2U+NTA/IDE6MC4wMSkqTG9nKE1heChDbG9zaW5nVmVsb2NpdHksIDEpKdIABWEvODAw0wAFYi8xODDUABtkLzgwMCAqIChhID4gMSkgKiAodiA+IDIwMCncAAQWAAAA3QAEFwAAAN4ABBkAAAAoIyRP5VkMnKUASau3WqUL/4wdUHJvamVjdGlsZSBhdm9pZGFuY2X8BQEBKCMiZ6xxS9Rho0+l3nzSNYH1c0ZvcnRyZXNzIG1hbm9ldXZyZQAABAIAAABUAQAOAAAABwAAAAAAAAAAXRsBAAAAAAAABAYAAABeAQAcAAAABwABAAAAAAAA5gIAAAAAAF0AAAAAAABdGwEAAAAAAAAEBwAAAL4BAA4AAAAHAAAAAAAAAABdGwEAAAAAAAAECAAAAMABAA4AAAAHAGkBAAAAAABdGwEAAAAAAAAEDgAAAMEBAA4AAAAHAGkBAAAAAABdGwEAAAAAAAAEDwAAAM0BAA4AAAAHAAAAAAAAAABdGwEAAAAAAAAEEAAAAM4BAA4AAAAHAAAAAAAAAABdGwEAAAAAAAAEEQAAAM8BAA4AAAAHAAAAAAAAAABdGwEAAAAAAAAEEgAAANABAA4AAAAHAAAAAAAAAABdGwEAAAAAAAAEEwAAANEBAA4AAAAHAAAAAAAAAABdGwEAAAAAAAAEFAAAANIBAA4AAAAHAAAAAAAAAABdGwEAAAAAAAAEFgAAANMBAA4AAAAHAAAAAAAAAABdGwEAAAAAAAAEFwAAANQBAA4AAAAHAAAAAAAAAABdGwEAAAAAAAAEGAAAANYBAA4AAAAHAA8AAAAAAABdGwEAAAcAAQAEAJi3RtcBAA4AAAAHAA8AAAAAAABdGwEAAAcAAQAEAJi3RiICAAcAAAAHAF0bAQAAAAAAAAQpAAAAogIAHAAAAAcAAQAAAAAAAAIAAAAAAAADAAAAAAAAXRsBAAAAAAAABDsAAAAKAwAjAAAAhQAPJwAAAAAAhM0AAAAAAIXNAAAAfgCGzQAAAH4AXRsBAAB+ANwABM3MTD3dAAQAAHpD3gAEmpmZPkABBM3MTD1BAQQAAHpDQgEEmpmZPqQBBM3MTD2lAQQAAHpDpgEEmpmZPggCBM3MTD0JAgQAAHpDCgIEmpmZPmwCBM3MTD1tAgQAAHpDbgIEmpmZPtACBM3MTD3RAgQAAHpD0gIEmpmZPgAABEYAAAALAwAjAAAAhQAPJwAAAAAAhM0AAAAAAIXNAAAAfgCGzQAAAH4AXRsBAAB+ANwABM3MTD3dAAQAAHpD3gAEmpmZPkABBM3MTD1BAQQAAHpDQgEEmpmZPqQBBM3MTD2lAQQAAHpDpgEEmpmZPggCBM3MTD0JAgQAAHpDCgIEmpmZPmwCBM3MTD1tAgQAAHpDbgIEmpmZPtACBM3MTD3RAgQAAHpD0gIEmpmZPgAABEcAAAAMAwAjAAAAhQAPJwAAAAAAhM0AAAAAAIXNAAAAfgCGzQAAAH4AXRsBAAB+ANwABM3MTD3dAAQAAHpD3gAEmpmZPkABBM3MTD1BAQQAAHpDQgEEmpmZPqQBBM3MTD2lAQQAAHpDpgEEmpmZPggCBM3MTD0JAgQAAHpDCgIEmpmZPmwCBM3MTD1tAgQAAHpDbgIEmpmZPtACBM3MTD3RAgQAAHpD0gIEmpmZPgAABEgAAAANAwAjAAAAhQAPJwAAAAAAhM0AAAAAAIXNAAAAfgCGzQAAAH4AXRsBAAB+ANwABM3MTD3dAAQAAHpD3gAEmpmZPkABBM3MTD1BAQQAAHpDQgEEmpmZPqQBBM3MTD2lAQQAAHpDpgEEmpmZPggCBM3MTD0JAgQAAHpDCgIEmpmZPmwCBM3MTD1tAgQAAHpDbgIEmpmZPtACBM3MTD3RAgQAAHpD0gIEmpmZPgAABEkAAAAOAwAjAAAAhQAPJwAAAAAAhM0AAAAAAIXNAAAAfgCGzQAAAH4AXRsBAAB+ANwABM3MTD3dAAQAAHpD3gAEmpmZPkABBM3MTD1BAQQAAHpDQgEEmpmZPqQBBM3MTD2lAQQAAHpDpgEEmpmZPggCBM3MTD0JAgQAAHpDCgIEmpmZPmwCBM3MTD1tAgQAAHpDbgIEmpmZPtACBM3MTD3RAgQAAHpD0gIEmpmZPgAABEoAAAAUAwAOAAAADgAAAAAAAAAAXRsBAAAHAAAABDMzb0IAAARQAAAAFQMADgAAAA4AAAAAAAAAAF0bAQAABwAAAASamW9CAAAEUQAAABYDAA4AAAAOAAAAAAAAAABdGwEAAAcAAAAEzcxuQgAABFIAAAAXAwAOAAAADgAAAAAAAAAAXRsBAAAHAAAABAAAcEIAAARTAAAAGAMADgAAAA4AAAAAAAAAAF0bAQAABwAAAARmZm5CAAAEVAAAAA==","VehicleData":"RykBAAAAAAAVAAAAAAAAAAAAAAAAcycAAAAAAGQAAAAAAABXLgAAAAAAAAcAAAAAAAAAAAAAAADwWwoBAAAAAA4AAAAAAA8nAAAAAADQBwAAAAAAn3EEAAAAAAAOAAAAAAAPJwAAAAAAoIYBAAAAAMF9Vp8AAAAABwAAAAcAAAAAAAAAAAAABAEAAAA57QcAAAAAAAcAAAAHAAEAAAAAAAAAAASmp2E9PjUUAAAAAAAHAAAAIwABAAAAAAAACgAEzczMPQsABM3MzD0MAATNzMw9DQAEzczMPQ4ABM3MzD1SQwAAAAAAAAcAAAAAAAEAAAAAAADESgAAAAAAAAcAAAAcAAAAAAAAAAAAAAQIZ4FIAQAExmnlQwIABEzE0EsDAASsaaVHK94KAAAAAAAHAAAACAABAAAAAAAAAAABAAEAAQAyjlAAAAAAAAcAAAAAAAAAAAAAAADQq2UAAAAAAA4AAAALAAAAAAAAAAABAAAAAAsAAwABAREABAEAAAAuywQAAAAAAAcAAAAAACSIAAAAAADCJ2EAAAAAAAcAAABGAAAAAAAAAAAAAAQAAEhCCgAEAADIwQ8ABAAAXEIUAAQAAPpDGQAEAIA7RTIABABAHEY3AAQAQBxGHgAEAACAPyMABAAAgD8oAAQAAKBBEugBAAAAAAAOAAAAAAAPJwAAAAAAoIYBAAAAAKH5VgAAAAAADgAAAAAADycAAAAAAKBjbwAAAAA=","designChanged":false,"blueprintVersion":14,"blueprintName":"Projectile Tracking Testing Fortress","SerialisedInfo":{"JsonDictionary":{},"IsEmpty":true},"Name":null,"ItemNumber":592,"LocalPosition":"10042.13,17.46416,10068.27","LocalRotation":"0,0.9876842,0,-0.1564608","ForceId":211938175,"TotalBlockCount":815,"MaxCords":"15,10,18","MinCords":"-15,-4,-18","BlockIds":[1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,299,1132,300,299,299,299,299,321,321,321,321,321,321,321,321,321,321,321,321,321,299,299,299,299,299,299,299,299,299,299,321,321,321,321,321,321,321,321,321,321,321,321,321,321,321,321,321,321,321,321,321,321,191,191,299,299,299,299,299,296,301,344,228,258,1087,1087,1087,1087,1087,1087,234,279,279,279,279,596,596,596,596,596,596,596,596,596,596,596,596,596,596,596,596,1213,1213,1213,1213,1213,1213,1213,1213,1213,1213,1213,1213,1213,1213,1213,1213,1213,1213,1213,1213,1213,1213,1213,1213,1212,1212,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,488,490,347,349,299,330,330,330,330,330,330,330,330,330,330,348,334,334,309,336,311,326,339,567,557,557,556,556,553,553,553,553,553,553,553,553,553,553,562,562,562,562,562,562,562,562,562,553,553,562,562,562,562,562,562,562,562,562,562,561,561,561,562,561,561,561,561,561,561,561,561,561,561,561,561,561,561,561,590,590,590,590,553,553,553,562,562,562,562,553,561,561,561,561,561,561,561,561,565,1132,494,561,562,561,562,561,562,562,561,562,561,562,561,553,553,553,553,553,553,562,561,562,561,562,561,562,562,561,562,561,562,561,562,553,553,553,553,553,553,561,562,561,562,561,562,562,561,562,561,562,561,259,259,915,936,923,922,935,929,936,937,924,910,910,924,937,924,926,924,922,923,936,256,256,915,257,259,257,935,922,923,936,929,914,917,914,917,914,917,914,917,913,917,910,935,917,913,917,935,914,917,914,917,914,917,914,934,923,922,935,935,937,915,924,910,924,911,924,926,917,913,917,913,935,917,911,917,935,919,916,916,916,916,916,916,916,928,917,913,917,913,935,917,911,917,935,935,937,924,924,910,924,911,924,926,924,923,922,935,914,917,914,917,914,917,914,917,913,917,910,935,917,913,917,935,914,917,914,917,914,917,914,935,922,923,936,929,256,915,257,259,257,924,922,923,936,256,936,937,924,910,910,924,937,924,926,936,923,922,935,929,259,259,915,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,1134,551,551,551,551,551,551,300,300,300,300,300,296,296,296,296,296,301,301,301,301,301,1133],"BlockState":"=0,794","AliveCount":794,"BlockStringData":["-- Settings\r\n-- use pCall to avoid crash, retry if failed\r\nlocal AllowErrorRecovery = false\r\n\r\n-- seconds to record target movements for\r\nlocal targetTrackTime = 15\r\n-- number of locations to track per enemy (todo: support tracking multiple projectiles)\r\n  -- currently not useful as a single shell will generate duplicate origins. To be fixed\r\nlocal numOrigins = 1\r\n-- time between switching targets\r\nlocal originSwitchTime = 0.25\r\n-- maximum time to remember origin points\r\nlocal maxStaleness = 3\r\n-- todo: move range and altitude limits to weapon definitions\r\n-- ranges to engage\r\nlocal minRange = 50\r\nlocal maxRange = 2000\r\n-- altitudes to engage (estimated altitude of firing piece, not target origin)\r\n  -- checked when adding an origin and when firing\r\nlocal minAlt = 0\r\nlocal maxAlt = math.huge\r\n-- parameters to find weapons (Shift+N to name turret blocks)\r\n  -- different turrets should have different names even if they have the same weapon\r\n  -- if all weapons on a turret have the same muzzle velocity then just name the turret\r\n  -- if multiple weapons on same turret with different muzzle velocity then name the turret,\r\n    -- leave primary weapon unnamed and give secondary weapons unique names\r\n    -- turret name should go before names of secondary weapons\r\n  -- checkACB lists ACBs set to detect object presence and trigger custom axis\r\n    -- may also have second ACB with inverted settings that trigger negative custom axis\r\n    -- will be checked before firing to make sure blocks actually exist at target distance\r\n    -- this check is not performed when firing at aimpoint due to idle mode \"fire\" or \"timer\"\r\n    -- validRequire is required number of ACBs in range and pointing in the right direction\r\n    -- checkRequire is proportion of valid ACBs that are have detected an object\r\nlocal weaponDef = {\r\n  {\r\n    name = \"laser\",\r\n    checkACBs = {\r\n      { axis = \"check\", minRange = 200, maxRange = 2400, turretName = \"checkTurret\", offset = Vector3(0, 1, 0), },\r\n    },\r\n    checkRequire = 1,\r\n    validRequire = 0,\r\n  }\r\n}\r\n-- indexes of mainframes to be used to track enemy rotations\r\n  -- 3 is the bare minimum, but will fail if any of them target a subconstruct\r\n  -- so more is preferred\r\n  -- it will also fail if too many mainframes switch their aimpoint simultaneously\r\n  -- this is unavoidable in the case of blocks being destroyed, but can be avoided\r\n  -- in the case of the timer switching blocks. Todo: manage switch times to avoid\r\n  -- synchronized aimpoint switching\r\nlocal aimPointTrackers = {\r\n  { idx = 1 },\r\n  { idx = 2 },\r\n  { idx = 3 },\r\n  { idx = 4 },\r\n  { idx = 5 },\r\n}\r\n-- which mainframe to use, will affect target prioritization\r\n  -- currently only fires at the highest priority target\r\n  -- can be the same as one of the aimPointTrackers\r\nlocal mainframeIdx = 0\r\n-- what to do when no firing origin detected\r\n  -- timer: wait for waitTime seconds, then fire at current target if no origin found\r\n  -- fire: aim and fire at current target\r\n  -- enemy: aim at current target\r\n  -- none: return to idle position\r\n  -- last: continue aiming at last absolute bearing\r\nlocal idleAim = \"timer\"\r\n  -- time to wait for a new origin before firing at the aimpoint\r\n    -- only used in idle aim mode \"timer\"\r\nlocal waitTime = 10\r\n-- offset the aimpoint, i.e. for hitting the necks, tetris, or turret bases instead of the barrels\r\n  -- is a function with the following properties:\r\n  --[[\r\n    Arguments:\r\n      fp - the original aimpoint\r\n      target - the target position\r\n      isCounter - whether we are firing at an origin detected by the counterbattery script or just the AI aimpoint\r\n    Returns:\r\n      fpOffset - the offset of the adjusted aimpoint relative to the original aimpoint\r\n  ]]\r\n  -- to adjust depending on estimated turret location\r\n-- todo: return list of locations to attempt, using the checkACBs to check each one\r\nlocal function aimOffset(fp, target, isCounter)\r\n  return Vector3.zero\r\nend\r\n-- when tracking rotation, reject any rotation estimates above this rate (in deg/s)\r\nlocal maxTurnRateTracking = 720\r\n-- whether or not to attempt to snipe missile launchers\r\n  -- since missiles can turn, we can't trace back their trajectory\r\n  -- however, if we detect a missile the instant it is launched (most feasible for huge missiles\r\n    -- and large missiles with low ramp time, no ignition delay, and high thrust),\r\n  -- we can approximate the missile as traveling in a straight line\r\nlocal missileCounter = true\r\n-- degrees of inaccuracy allowed when firing\r\n-- weapon will start firing within this angle\r\n-- but will always try to obtain perfect accuracy\r\nlocal AIM_TOL = 0.1\r\n-- physics ticks per second (Lua runs in sync with game physics)\r\nlocal TICKS_PER_S = 40\r\n\r\n-- todo: Integrate with enemy identififcation script to get weapon distances from origin,\r\n    -- and trace to that distance from origin instead of closest\r\n-- todo: Account for target acceleration\r\n\r\n-- one way to store previous values is in local variables outside of Update like this\r\n  -- another way is to use global variables, which has the benefit of being able to be\r\n  -- located near where they are used, but are much slower to access (requires a table lookup)\r\nlocal lastProjectilePos\r\nlocal enemies\r\nlocal currentLine\r\nlocal lastFrameTime\r\nlocal inited\r\nlocal prevTime\r\nlocal lastOrigin\r\nlocal lastOriginSwitchTime = 0\r\nlocal currentTargetId\r\nlocal originPopTime = 0\r\nlocal lastAim\r\nlocal nextRecordTime\r\nlocal continueLine = false\r\nlocal turrets = {}\r\n\r\nlocal BlockUtil = {}\r\nlocal Combat = {}\r\nlocal StringUtil = {}\r\nlocal Accumulator = {}\r\nlocal Differ = {}\r\nlocal Graph = {}\r\nlocal Heapq = {}\r\nlocal LinkedList = {}\r\nlocal MathUtil = {}\r\nlocal RingBuffer = {}\r\nlocal VectorN = {}\r\nlocal Control = {}\r\nlocal Nav = {}\r\nlocal Scheduling = {}\r\nlocal Targeting = {}\r\n\r\nfunction Init(I)\r\n  for idx, weapon in ipairs(weaponDef) do\r\n    turrets[idx] = BlockUtil.getWeaponsByName(I, weapon.name)\r\n    for acbIdx, acb in ipairs(weapon.checkACBs) do\r\n      acb.turretSub = BlockUtil.getSubConstructsByName(I, acb.turretName, 1)[1]\r\n      acb.turret = BlockUtil.getWeaponsByName(I, acb.turretName, 1)[1]\r\n    end\r\n  end\r\n\r\n  nextRecordTime = I:GetTimeSinceSpawn()\r\n  enemies = {}\r\n  math.randomseed(I:GetTime())\r\n  math.random()\r\n  math.random()\r\n\r\n  originPopTime = I:GetTimeSinceSpawn()\r\n  inited = true\r\nend\r\n\r\nfunction Update(I)\r\n  --I:ClearLogs()\r\n  --I:Log(string.format(\"Game Time: %.2f\", I:GetTimeSinceSpawn()))\r\n  if AllowErrorRecovery then\r\n    ProtectedUpdate(I)\r\n  else\r\n    CoreUpdate(I)\r\n  end\r\nend\r\n\r\nfunction ProtectedUpdate(I)\r\n  local updateRan, err = pcall(CoreUpdate, I)\r\n  if not updateRan then\r\n    I:Log(\"Error in Update\")\r\n    I:Log(err)\r\n    return false --This means we had an error, so just move on in the LUA.\r\n  else\r\n    I:Log(\"Ran update\")\r\n  end\r\nend\r\n\r\nfunction CoreUpdate(I)\r\n  if not inited then Init(I) end\r\n  local target = I:GetTargetInfo(mainframeIdx, 0)\r\n  if not target or not target.Valid then\r\n    return\r\n  end\r\n  currentTargetId = target.Id\r\n  local t = I:GetTimeSinceSpawn()\r\n\r\n  if t >= nextRecordTime - 0.5 / TICKS_PER_S then\r\n    UpdateEnemyData(I)\r\n    nextRecordTime = nextRecordTime + 1 / TICKS_PER_S\r\n  end\r\n\r\n  local frameTime = lastFrameTime and t - lastFrameTime or 0\r\n  lastFrameTime = t\r\n  -- calculate projectile location\r\n  local alt = 800 * I:GetPropulsionRequest(9) -- A axis, set in projectile avoidance routine\r\n  local relBear = 180 * I:GetPropulsionRequest(10) -- B axis\r\n  local dist = 800 * I:GetPropulsionRequest(12) -- D axis\r\n\r\n  local projectile = dist * Vector3.forward\r\n  projectile = Quaternion.AngleAxis(I:GetConstructYaw() + relBear, Vector3.up) * projectile\r\n  projectile = projectile + I:GetConstructCenterOfMass()\r\n  projectile.y = alt\r\n\r\n  if dist == 0 then\r\n    currentLine = nil\r\n    lastProjectilePos = nil\r\n  end\r\n\r\n  if missileCounter then\r\n    for widx = 0, I:GetNumberOfWarnings(0) - 1 do\r\n      local warn = I:GetMissileWarning(mainframeIdx, widx)\r\n      if warn.Valid and warn.TimeSinceLaunch < 0.1 then\r\n        local launcherPos = warn.Position - warn.TimeSinceLaunch * warn.Velocity\r\n        local targetPosAtLaunch = target.Position - warn.TimeSinceLaunch * target.Velocity\r\n        -- todo: set threshold by target size\r\n        if (launcherPos - targetPosAtLaunch).sqrMagnitude < 150 * 150 then\r\n          local closestAlt = launcherPos.y\r\n          if closestAlt > minAlt and closestAlt < maxAlt then\r\n            local enemy = enemies[target.Id]\r\n            local eRot = enemy.rotation[enemy.rotation.size] or Quaternion.Identity\r\n            local lPos = Quaternion.Inverse(eRot) * (launcherPos - targetPosAtLaunch)\r\n            RingBuffer.push(enemy.origins, lPos)\r\n            RingBuffer.push(enemy.originTimes, t)\r\n          end\r\n        end\r\n      end\r\n    end\r\n  end\r\n\r\n  -- compare to past projectile locations\r\n  -- to make sure we're tracking the same projectile\r\n\r\n  -- see if it matches current line\r\n  -- todo: store multiple lines and find match\r\n\r\n  -- 2/3rds the estimated drop in two frames due to gravity\r\n  -- inconsistent with theoretical formula due to discrete integration\r\n  -- powered missiles have no gravity so their expected error\r\n  -- is the negative of the drop due to gravity\r\n  local eps = 10 * frameTime * frameTime\r\n  -- todo: maybe limit how often the line tracing runs to save processing power\r\n  if lastProjectilePos and currentLine and CheckAndUpdateLine(I, currentLine, projectile, frameTime, eps) then\r\n    if not continueLine then\r\n      local enemy = enemies[currentTargetId]\r\n      local origin = GetOrigin(I, projectile, enemy)\r\n      if origin then\r\n        RingBuffer.push(enemy.origins, origin)\r\n        RingBuffer.push(enemy.originTimes, t)\r\n      end\r\n    end\r\n    continueLine = true\r\n  else\r\n    continueLine = false\r\n    if lastProjectilePos and dist > 0 then\r\n      local start = lastProjectilePos\r\n      currentLine = {\r\n        start = start,\r\n        tStart = t - 1 / TICKS_PER_S,\r\n        ed = projectile\r\n      }\r\n      currentLine.dv = -frameTime * I:GetGravityForAltitude(start.y).y\r\n      currentLine.dy = frameTime * currentLine.dv\r\n      currentLine.ds = projectile + currentLine.dy * Vector3.up - start\r\n      currentLine.dt = frameTime\r\n      currentLine.ev = projectile - start\r\n      prevTime = nil\r\n    end\r\n  end\r\n\r\n  lastProjectilePos = projectile\r\n\r\n  -- fire weapon at origins\r\n  local enemy = enemies[currentTargetId]\r\n  local eRot = enemy.rotation[enemy.rotation.size] or Quaternion.identity\r\n  local fp\r\n  if lastOriginSwitchTime + originSwitchTime > t then\r\n    fp = lastOrigin and eRot * lastOrigin\r\n  end\r\n  if not fp then\r\n    while enemy.origins.size > 0 and t - enemy.originTimes[1] > maxStaleness do\r\n      RingBuffer.pop(enemy.origins)\r\n      RingBuffer.pop(enemy.originTimes)\r\n      originPopTime = t\r\n    end\r\n    if enemy.origins.size > 0 then\r\n      lastOrigin = enemy.origins[math.random(1, enemy.origins.size)]\r\n      fp = eRot * lastOrigin\r\n      if fp.y + target.Position.y < minAlt or fp.y + target.Position.y > maxAlt then\r\n        -- do a linear search to find valid origin\r\n        local found = false\r\n        for i = 1, enemy.origins.size do\r\n          lastOrigin = enemy.origins[i]\r\n          fp = eRot * lastOrigin\r\n          if fp.y + target.Position.y > minAlt and fp.y + target.Position.y < maxAlt then\r\n            found = true\r\n            break\r\n          end\r\n        end\r\n        if not found then\r\n          fp = nil\r\n          lastOrigin = nil\r\n        end\r\n      end\r\n    end\r\n    lastOriginSwitchTime = t\r\n  end\r\n  for i, turret in ipairs(turrets) do\r\n    local wfp\r\n    local ready = false\r\n    if fp then\r\n      -- check ACBs for object presence\r\n      local success = 0\r\n      local valid = 0\r\n      wfp = fp + aimOffset(fp, target.Position, true)\r\n      for acbIdx, acb in ipairs(weaponDef[i].checkACBs) do\r\n        local bInfo = I:GetSubConstructInfo(acb.turretSub)\r\n        local r = wfp + target.Position - (bInfo.Position + bInfo.Rotation * acb.offset)\r\n        BlockUtil.aimWeapon(I, acb.turret, r, 0)\r\n        if r.magnitude > acb.minRange and r.magnitude < acb.maxRange\r\n            and I:IsAlive(acb.turretSub)\r\n            and Vector3.Angle(r, bInfo.Forwards) < AIM_TOL then\r\n          valid = valid + 1\r\n          if I:GetCustomAxis(acb.axis) > 0 then\r\n            success = success + 1\r\n          end\r\n        end\r\n      end\r\n      ready = valid >= weaponDef[i].validRequire and success >= weaponDef[i].checkRequire * valid\r\n    end\r\n    wfp = ready and wfp or (target.AimPointPosition - target.Position + aimOffset(fp, target.Position, false))\r\n    ready = ready or (idleAim == \"fire\" or (idleAim == \"timer\" and t - originPopTime > waitTime))\r\n    for j, weapon in ipairs(turret) do\r\n      local aim\r\n      local fire = false\r\n      local wInfo = BlockUtil.getWeaponInfo(I, weapon)\r\n      if ready then\r\n        if wInfo.Speed >= 1e5 then\r\n          local range = (wfp + target.Position - I:GetConstructPosition()).magnitude\r\n          if range > minRange and range < maxRange then\r\n            aim = wfp + target.Position - wInfo.GlobalFirePoint\r\n            fire = true\r\n          end\r\n        else\r\n          local g = 0.5 * (I:GetGravityForAltitude(I:GetConstructPosition().y) + I:GetGravityForAltitude(target.Position.y))\r\n          aim = Targeting.secondOrderTargeting(wfp + target.Position - wInfo.GlobalFirePoint,\r\n                      target.Velocity - I:GetVelocityVector(),\r\n                      -g,\r\n                      wInfo.Speed, minRange, maxRange)\r\n          if aim then fire = true end\r\n        end\r\n      end\r\n      if not aim then\r\n        if idleAim == \"enemy\" or idleAim == \"fire\" or idleAim == \"timer\" then\r\n          aim = target.Position - wInfo.GlobalFirePoint\r\n        elseif idleAim == \"last\" then\r\n          aim = lastAim\r\n        end\r\n      end\r\n      if aim then\r\n        lastAim = aim\r\n        if Combat.CheckConstraints(I, aim, weapon.wpnIdx, weapon.subIdx) then\r\n          BlockUtil.aimWeapon(I, weapon, aim, 0)\r\n          if fire and Vector3.Angle(wInfo.CurrentDirection, aim) < AIM_TOL then\r\n            BlockUtil.fireWeapon(I, weapon, 0)\r\n          end\r\n        end\r\n      end\r\n    end\r\n  end\r\nend\r\n\r\nfunction UpdateEnemyData(I)\r\n  for id, en in pairs(enemies) do\r\n    en.valid = false\r\n  end\r\n  for tarIdx = 0, I:GetNumberOfTargets(mainframeIdx) - 1 do\r\n    local target = I:GetTargetInfo(mainframeIdx, tarIdx)\r\n    if target.Valid then\r\n      if not enemies[target.Id] then\r\n        local rbsize = targetTrackTime * TICKS_PER_S\r\n        enemies[target.Id] = {\r\n                              pos = RingBuffer.RingBuffer(rbsize),\r\n                              vel = RingBuffer.RingBuffer(rbsize),\r\n                              rotation = RingBuffer.RingBuffer(rbsize),\r\n                              origins = RingBuffer.RingBuffer(numOrigins),\r\n                              originTimes = RingBuffer.RingBuffer(numOrigins),\r\n                              valid = true,\r\n                              oldAimpoints = {},\r\n                              aimpoints = {},\r\n                            }\r\n      end\r\n      local e = enemies[target.Id]\r\n      e.valid = true\r\n      RingBuffer.push(e.pos, target.Position)\r\n      RingBuffer.push(e.vel, target.Velocity)\r\n    end\r\n  end\r\n\r\n  -- have to do this because there is no get target by id function\r\n  for id, en in pairs(enemies) do\r\n    if not en.valid then\r\n      enemies[id] = nil\r\n      if id == currentTargetId then\r\n        lastOrigin = nil\r\n        lastOriginSwitchTime = I:GetTimeSinceSpawn()\r\n      end\r\n    end\r\n  end\r\n\r\n  for idx, tracker in ipairs(aimPointTrackers) do\r\n    for tarIdx = 0, I:GetNumberOfTargets(tracker.idx) - 1 do\r\n      local target = I:GetTargetInfo(tracker.idx, tarIdx)\r\n      if target.Valid then\r\n        local e = enemies[target.Id]\r\n        e.oldAimpoints[idx] = e.aimpoints[idx] or target.AimPointPosition\r\n        e.aimpoints[idx] = target.AimPointPosition\r\n      end\r\n    end\r\n  end\r\n\r\n  for id, en in pairs(enemies) do\r\n    local dRot = GetRotation(en.oldAimpoints, en.aimpoints) or Quaternion.identity\r\n    RingBuffer.push(en.rotation, dRot * (en.rotation[en.rotation.size] or Quaternion.identity))\r\n  end\r\nend\r\n\r\nfunction GetOrigin(I, projectile, enemy)\r\n  if prevTime and RingBuffer.isFull(enemy.pos) then\r\n    prevTime = prevTime - 1\r\n  end\r\n  local vel = currentLine.ds / currentLine.dt\r\n  local relVel = vel - enemy.vel[enemy.vel.size]\r\n  local relPos = projectile - enemy.pos[enemy.pos.size]\r\n  local time2d = math.sqrt((relPos.x ^ 2 + relPos.z ^ 2) / (relVel.x ^ 2 + relVel.z ^2))\r\n  local estimate2d = relPos - (relVel * time2d) + 0.5 * I:GetGravityForAltitude(currentLine.start.y) * time2d * time2d\r\n  -- todo: adjust threshold based on enemy size, also penalize vertical error greater than horizontal\r\n  if estimate2d.sqrMagnitude < 150 * 150 then\r\n    local p, t = CheckIfCram(projectile, vel, enemy.pos[enemy.pos.size], 150)\r\n    if p then\r\n      I:Log(\"Projectile determined to be CRAM shell, fired \"..t..\" seconds ago\")\r\n      local pIdx = enemy.pos.size + t * TICKS_PER_S\r\n      if pIdx < 1 then\r\n        I:Log(\"CRAM direct guess has no target data\")\r\n        return\r\n      end\r\n      local enemyPosAtTime = enemy.pos[pIdx]\r\n      local enemyRotAtTime = enemy.rotation[pIdx]\r\n      if enemyPosAtTime then\r\n        return Quaternion.Inverse(enemyRotAtTime) * (p - enemyPosAtTime)\r\n      end\r\n      return\r\n    end\r\n    local closest, closestTimeIdx = RunTrace(I, currentLine, enemy, prevTime)\r\n    if not closest then\r\n      I:Log(\"no solution found\")\r\n      prevTime = nil\r\n      return\r\n    end\r\n    prevTime = closestTimeIdx\r\n    if closest.sqrMagnitude < 100 * 100 then\r\n      local closestAlt = closest.y + enemy.pos[closestTimeIdx].y\r\n      if closestAlt > minAlt and closestAlt < maxAlt then\r\n        return Quaternion.Inverse(enemy.rotation[closestTimeIdx]) * closest\r\n      end\r\n    end\r\n  end\r\nend\r\n\r\nfunction GetRotation(oldPts, newPts, iterLim)\r\n  local nTrack = #newPts\r\n  iterLim = iterLim or 10\r\n\r\n  local indices = {}\r\n  for i=1, nTrack do\r\n    indices[i] = i\r\n  end\r\n  -- iterate through triples of aimpoints, check if the legs are the same length\r\n  for trip=1, iterLim do\r\n    -- not the most efficient as we shuffle the entire list even though we only need the first 3. Implement range shuffle later\r\n    MathUtil.shuffle(indices, true)\r\n    local oldAimpoints = {}\r\n    local aimpoints = {}\r\n    for i=1, 3 do\r\n      oldAimpoints[i] = oldPts[indices[i]]\r\n      aimpoints[i] = newPts[indices[i]]\r\n    end\r\n\r\n    local legs, oldLegs = {}, {}\r\n    local valid = true\r\n    for i=1, 3 do\r\n      legs[i] = aimpoints[i % 3 + 1] - aimpoints[(i - 1) % 3 + 1]\r\n      oldLegs[i] = oldAimpoints[i % 3 + 1] - oldAimpoints[(i - 1) % 3 + 1]\r\n      -- check if aimpoints have changed\r\n      if math.abs(legs[i].sqrMagnitude - oldLegs[i].sqrMagnitude) > 0.1 then\r\n        valid = false\r\n        break\r\n      end\r\n    end\r\n    if valid then\r\n      local oldRot = Quaternion.LookRotation(oldLegs[1], oldLegs[2])\r\n      local rot = Quaternion.LookRotation(legs[1], legs[2])\r\n      local deltaRot = rot * Quaternion.Inverse(oldRot)\r\n      if math.acos(math.max(math.min(deltaRot.w, 1), -1)) * 360 / math.pi * TICKS_PER_S < maxTurnRateTracking then\r\n        -- check for consensus\r\n        local votes = 0\r\n        for idx, ap in ipairs(newPts) do\r\n          local diff = ap - newPts[indices[1]]\r\n          local oldDiff = oldPts[idx] - oldPts[indices[1]]\r\n          if (diff - deltaRot * oldDiff).sqrMagnitude < 0.1 then\r\n            votes = votes + 1\r\n            if 2 * votes - 3 >= nTrack then\r\n              return deltaRot\r\n            end\r\n          end\r\n        end\r\n      end\r\n    end\r\n  end\r\n  return nil\r\nend\r\n\r\nfunction CheckIfCram(projPos, projVel, enemyPos, tolerance)\r\n  -- y component of velocity changes, but horizontal does not\r\n  -- if horizontal alone exceeds max CRAM speed, cannot be CRAM\r\n  -- no matter what y component becomes\r\n  local hSqrMag = projVel.x * projVel.x + projVel.z * projVel.z\r\n  -- CRAMs usually aren't fired underwater, and if they are, this method breaks anyways \r\n  local speedAtSeaLevel = math.sqrt(2 * projPos.y * 9.81 + projVel.sqrMagnitude)\r\n  local maybeD = hSqrMag <= 90000 and speedAtSeaLevel >= 300\r\n  local maybeS = hSqrMag <= 57600 and speedAtSeaLevel >= 240\r\n  local p, t1, t2\r\n  if maybeD then\r\n    t1, t2 = GetCramLaunchTime(projVel, 300)\r\n    if t2 <= 0 then\r\n      p = CheckPosition(projPos, projVel, enemyPos, t2, tolerance)\r\n      if p then return p, t2 end\r\n    end\r\n    if t1 <= 0 then\r\n      p = CheckPosition(projPos, projVel, enemyPos, t1, tolerance)\r\n      if p then return p, t1 end\r\n    end\r\n  end\r\n  if maybeS then\r\n    t1, t2 = GetCramLaunchTime(projVel, 240)\r\n    if t2 <= 0 then\r\n      p = CheckPosition(projPos, projVel, enemyPos, t2, tolerance)\r\n      if p then return p, t2 end\r\n    end\r\n    if t1 <= 0 then\r\n      p = CheckPosition(projPos, projVel, enemyPos, t1, tolerance)\r\n      if p then return p, t1 end\r\n    end\r\n  end\r\nend\r\n\r\nfunction CheckPosition(projPos, projVel, enemyPos, t, tolerance)\r\n  local p = projPos + projVel * t - 0.5 * Vector3(0, 9.81, 0) * t * t\r\n  if (p - enemyPos).sqrMagnitude < tolerance * tolerance then\r\n    return p\r\n  end\r\nend\r\n\r\n-- provides the launch time in seconds before present\r\n-- assuming initial velocity of either 240 or 300m/s\r\nfunction GetCramLaunchTime(vel, muzzle)\r\n  local hSqrMag = vel.x * vel.x + vel.z * vel.z\r\n\r\n  local yvel = math.sqrt(muzzle * muzzle - hSqrMag)\r\n  return (vel.y - yvel) / 9.81, (vel.y + yvel) / 9.81\r\nend\r\n\r\nfunction CheckAndUpdateLine(I, line, projectile, frameTime, tolerance)\r\n  local expected = line.ed + line.ev + frameTime * frameTime * I:GetGravityForAltitude(line.ed.y)\r\n  local dv = line.dv - frameTime * I:GetGravityForAltitude(line.ed.y).y\r\n  local dy = line.dy + frameTime * line.dv\r\n  if (expected - projectile).sqrMagnitude <= tolerance * tolerance then\r\n    line.ds = projectile + line.dy * Vector3.up - line.start\r\n    line.dv = dv\r\n    line.dy = dy\r\n    line.dt = I:GetTimeSinceSpawn() - line.tStart\r\n    line.ev = projectile - line.ed\r\n    line.ed = projectile\r\n    return true\r\n  end\r\n  return false\r\nend\r\n\r\nfunction RunTrace(I, line, enemy, timeGuess)\r\n  local t = I:GetTimeSinceSpawn()\r\n  local totalIter = 0\r\n  local targetPos = enemy.pos[enemy.pos.size]\r\n  local targetVel = enemy.vel[enemy.vel.size]\r\n  if timeGuess then\r\n    if enemy.pos[timeGuess] then\r\n      targetPos = enemy.pos[timeGuess]\r\n      targetVel = enemy.vel[timeGuess]\r\n    else\r\n      I:Log(\"initial guess has no target data\")\r\n    end\r\n  end\r\n  local tIdxClosest\r\n  for i = 1, timeGuess and 2 or 3 do\r\n    -- find the point of closest approach based on current target position and velocity\r\n    -- x(t) = x_i + v_x t\r\n    -- z(t) = z_i + v_z t\r\n    -- y(t) = y_i + v_y t + 0.5gt^2\r\n    -- squared distance = x^2 + y^2 + z^2\r\n\r\n    -- d/dt sqrDistance = \r\n    -- 2 x_i v_x + 2 v_x^2 t +\r\n    -- 2 z_i v_z + 2 v_z^2 t +\r\n    -- 2 y_i v_y + 2 v_y^2 t + 2 y_i g t + 3 v_y g t^2 + 0.25 g^2 t^3\r\n    -- this is a cubic polynomial in terms of t which we can find the roots of\r\n    local ti = (line.tStart + line.dt) - (timeGuess and t - (enemy.pos.size - timeGuess) / TICKS_PER_S or t)\r\n    local di = line.ed - targetPos + ti * targetVel\r\n    local projRelVel = line.ds / line.dt - line.dv * Vector3.up - targetVel\r\n    -- accounting exactly for gravity changes over altitude is difficult, just approximate and hope the enemy isn't using mortars\r\n    local g = I:GetGravityForAltitude(line.ed.y).y\r\n    local a, b, c = MathUtil.solveCubic(0.125 * g * g, 1.5 * projRelVel.y * g, projRelVel.sqrMagnitude + di.y * g, Vector3.Dot(di, projRelVel))\r\n    -- critical point is a minimum when derivative changes from negative to positive\r\n    -- since leading term is always positive (0.125g^2 = 12.2), if there are three roots, the first and third are minima\r\n    -- if there is one root, it is a minimum\r\n    -- minRoot is in seconds relative to line.tStart + line.dt\r\n    local minRoot\r\n    if a and b and c then\r\n      local firstRoot = math.min(a, b, c)\r\n      local lastRoot = math.max(a, b, c)\r\n      local firstSqrDist = SqrDistance(I, line, targetPos, targetVel, firstRoot)\r\n      local lastSqrDist = SqrDistance(I, line, targetPos, targetVel, lastRoot)\r\n      if firstSqrDist < lastSqrDist then\r\n        minRoot = firstRoot\r\n      else\r\n        minRoot = lastRoot\r\n      end\r\n    else\r\n      minRoot = a\r\n    end\r\n    -- get target position and velocity at estimated time of closest approach\r\n    local approachTime = minRoot + line.tStart + line.dt - t\r\n    tIdxClosest = math.floor(approachTime * TICKS_PER_S + 0.5) + enemy.pos.size\r\n    -- InterpolatedSearch(I, times, 1, times.size, minRoot + line.tStart + line.dt, true)\r\n    if not tIdxClosest then return nil end\r\n    targetPos = enemy.pos[tIdxClosest]\r\n    targetVel = enemy.vel[tIdxClosest]\r\n    if not targetPos then\r\n      I:Log(\"iterated guess has no target data\")\r\n      return nil\r\n    end\r\n  end\r\n\r\n  -- linear search to find best point\r\n  -- todo: account for target velocity\r\n  function CalcSqrDist(tIdx)\r\n    local dt = t - (enemy.pos.size - tIdx) / TICKS_PER_S - line.tStart\r\n    return (line.start - enemy.pos[tIdx] + dt * (line.ds / line.dt) + 0.5 * I:GetGravityForAltitude(line.start.y) * dt * dt).sqrMagnitude\r\n  end\r\n  local currentSqrDist = CalcSqrDist(tIdxClosest)\r\n  if tIdxClosest < enemy.pos.size then\r\n    local aftSqrDist = CalcSqrDist(tIdxClosest + 1)\r\n    while aftSqrDist < currentSqrDist and tIdxClosest < enemy.pos.size do\r\n      currentSqrDist = aftSqrDist\r\n      tIdxClosest = tIdxClosest + 1\r\n      if tIdxClosest < enemy.pos.size then\r\n        aftSqrDist = CalcSqrDist(tIdxClosest + 1)\r\n      end\r\n      totalIter = totalIter + 1\r\n      if totalIter >= 100 then\r\n        I:Log(\"max iterations exceeded on upwards search\")\r\n        break\r\n      end\r\n    end\r\n  end\r\n  --I:Log(totalIter..\" iterations after upwards search\")\r\n  if tIdxClosest > 1 then\r\n    local befSqrDist = CalcSqrDist(tIdxClosest - 1)\r\n    while befSqrDist < currentSqrDist and tIdxClosest > 1 do\r\n      currentSqrDist = befSqrDist\r\n      tIdxClosest = tIdxClosest - 1\r\n      if tIdxClosest > 1 then\r\n        befSqrDist = CalcSqrDist(tIdxClosest -1)\r\n      end\r\n      totalIter = totalIter + 1\r\n      if totalIter >= 100 then\r\n        I:Log(\"max iterations exceeded on downwards search\")\r\n        break\r\n      end\r\n    end\r\n  end\r\n  --I:Log(totalIter..\" iterations after downwards search\")\r\n  -- time of closest approach relative to line.tStart\r\n  local dt = t - (enemy.pos.size - tIdxClosest) / TICKS_PER_S - line.tStart\r\n  return line.start - enemy.pos[tIdxClosest] + dt * (line.ds / line.dt) + 0.5 * I:GetGravityForAltitude(line.start.y) * dt * dt, tIdxClosest\r\nend\r\n\r\nfunction SqrDistance(I, line, targetAbsPos, targetAbsVel, t)\r\n  local di = line.ed - targetAbsPos\r\n  local viRel = line.ds / line.dt - line.dv * Vector3.up - targetAbsVel\r\n  local diff = di + t * viRel + 0.5 * I:GetGravityForAltitude(line.ed.y) * t * t\r\n  return diff.sqrMagnitude\r\nend\r\n\r\nfunction InterpolatedSearch(I, list, left, right, target, findClosest, iterLim)\r\n  iterLim = iterLim or 50\r\n  local a, b, split\r\n  local totalIter = 0\r\n  while right > left do\r\n    a = list[left]\r\n    if a == target then return left end\r\n    if a > target then return findClosest and left or nil end\r\n    b = list[right]\r\n    if b == target then return right end\r\n    if b < target then return findClosest and right or nil end\r\n    split = math.floor((target - a) / (b - a) * (right - left) + left)\r\n    split = math.min(math.max(split, left + 1), right - 1)\r\n    if list[split] == target then return split end\r\n    if target < list[split] then\r\n      if findClosest and math.abs(list[split - 1] - target) > math.abs(list[split] - target) then\r\n        return split\r\n      end\r\n      right = split - 1\r\n    else\r\n      if findClosest and math.abs(list[split + 1] - target) > math.abs(list[split] - target) then\r\n        return split\r\n      end\r\n      left = split + 1\r\n    end\r\n    totalIter = totalIter + 1\r\n    if totalIter > iterLim then\r\n      I:Log(\"max iterations exceeded on InterpolatedSearch\")\r\n      break\r\n    end\r\n  end\r\n  return findClosest and left or nil\r\nend\r\n\r\n-- minified version of Tides library (not meant to be human-readable, see Tides.lua or individual class files for human-readable source)\r\nfunction Accumulator.Accumulator(a,b)local c={}c.decay=b;c.window=a;c.time=0;c.weight=0;if a>0 then c.vals=LinkedList.LinkedList()c.times=LinkedList.LinkedList()end;return c end;function Accumulator.update(c,d,e)local f=Mathf.Pow(c.decay,e)if not c.value then c.value=d*e else c.value=c.value*f;c.value=c.value+d*e end;c.time=c.time+e;c.weight=c.weight*f;c.weight=c.weight+e;if c.window>0 then LinkedList.pushFront(c.vals,d)LinkedList.pushFront(c.times,e)while c.time>c.window do local g=LinkedList.popBack(c.times)c.time=c.time-g;local h=Mathf.Pow(c.decay,c.time)c.weight=c.weight-g*h;c.value=c.value-LinkedList.popBack(c.vals)*g*h end end;return c.value,c.weight end;function Accumulator.get(c)return c.value,c.weight end;function Differ.Differ(i)local j={}j.lastVal=i;j.diff=nil;return j end;function Differ.update(j,d)if j.lastVal then j.diff=d-j.lastVal;j.lastVal=d end;j.lastVal=d;return j.diff end;function Differ.get(j)return j.diff end;function Heapq.Heapq(i,k)local l={}l.data=i;l.comp=k or function(m,n)return m<n end;local o=#l.data;l.size=o;for p=math.floor(o/2),1,-1 do Heapq.siftDown(l,p)end;return l end;function Heapq.siftDown(l,q)local r=false;local s=q;local o=#l.data;while not r do r=true;local t=2*s;local u=2*s+1;local v=s;if t<=o and l.comp(l.data[t],l.data[v])then v=t;r=false end;if u<=o and l.comp(l.data[u],l.data[v])then v=u;r=false end;if not r then local w=l.data[v]l.data[v]=l.data[s]l.data[s]=w;s=v end end end;function Heapq.siftUp(l,q)local r=false;local s=q;while not r do r=true;local x=math.floor(s/2)if l.comp(l.data[s],l.data[x])then local w=l.data[x]l.data[x]=l.data[s]l.data[s]=w;s=x;r=false end end end;function Heapq.insert(l,y)l.data[l.size+1]=y;l.size=l.size+1;Heapq.siftUp(l,l.size)end;function Heapq.pop(l)local z=l.data[1]l.data[1]=l.data[l.size]l.data[l.size]=nil;l.size=l.size-1;Heapq.siftDown(l,1)return z end;function Heapq.peek(l)return l.data[1]end;function Heapq.size(l)return l.size end;function LinkedList.LinkedList()local A={}A.value=nil;A.next=A;A.prev=A;return A end;function LinkedList.pushFront(B,d)local A={}A.value=d;LinkedList.connect(A,B.next)LinkedList.connect(B,A)end;function LinkedList.pushBack(B,d)local A={}A.value=d;LinkedList.connect(B.prev,A)LinkedList.connect(A,B)end;function LinkedList.popFront(B)local C=B.next.value;LinkedList.connect(B,B.next.next)return C end;function LinkedList.popBack(B)local C=B.prev.value;LinkedList.connect(B.prev.prev,B)return C end;function LinkedList.peekFront(B)return B.next.val end;function LinkedList.peekBack(B)return B.prev.val end;function LinkedList.connect(D,E)D.next=E;E.prev=D end;function LinkedList.toArray(B)local F=1;local G={}local A=B.next;while A~=B do G[F]=A.value;A=A.next end;return G end;function MathUtil.angleOnPlane(H,I,J)local K=Vector3.ProjectOnPlane(H,J)local g=Vector3.ProjectOnPlane(I,J)return Vector3.SignedAngle(K,g,J)end;function MathUtil.min(L,M)local N=nil;M=M or function(m,n)return m<n end;for O in L do if not N or M(O,N)then N=O end end;return N end;function MathUtil.max(L,M)local P=nil;M=M or function(m,n)return m<n end;for O in L do if not P or M(P,O)then P=O end end;return P end;function MathUtil.range(m,n,Q)local R,S=m,n;local T;if not m then return end;if not n then R=0;S=m;T=R<S and 1 or-1 elseif Q then T=Q end;return function(U,V)local W=V+T;if W==S then return nil end;return W end,nil,R-T end;function MathUtil.shuffle(B,X)local s=X and B or{}if not X then for F=1,#B do s[F]=B[F]end end;for F=#B,2,-1 do local Y=math.random(F)s[F],s[Y]=s[Y],s[F]end;return s end;function MathUtil.combine(m,n,Z)if#m==#n then local z={}for _,a0 in pairs(m)do z[_]=Z(_,a0,n[_])end;return z end end;function MathUtil.distribution()return{n=0}end;function MathUtil.updateDistribution(a1,a2)a1.n=a1.n+1;if a1.n==1 then a1.mean=a2;a1.covariance={}local h=#a2;for F=1,h do local a3={}for Y=1,h do a3[Y]=0 end;a1.covariance[F]=a3 end else a1.mean=a1.mean+1/(a1.n+1)*a2 end end;function MathUtil.mean(a1)return a1.mean end;function MathUtil.covariance(a1)return a1.cov end;function MathUtil.normal()local a4,a5=MathUtil.boxMuller()return a4 end;function MathUtil.normalPDF(a4)return math.exp(-0.5*a4*a4)/math.sqrt(2*math.pi)end;function MathUtil.normalCDF(a4)local a6=0.2316419;local a7=0.319381530;local a8=-0.356563782;local a9=1.781477937;local aa=-1.821255978;local ab=1.330274429;local g=1/(1+a6*a4)return 1-MathUtil.normalPDF(a4)*(a7*g+a8*g^2+a9*g^3+aa*g^4+ab*g^5)end;function MathUtil.inverseNorm(ac)local ad=ac>=0.5 and ac or-ac;local a4=5.55556*(1-((1-ad)/ad)^0.1186)if ac<0.5 then a4=-a4 end;return a4 end;function MathUtil.boxMuller()local ae=math.random()local af=math.random()af=math.random()af=math.random()local ag=math.sqrt(-2*math.log(ae))local ah=2*math.pi*af;return ag*math.cos(ah),ag*math.sin(ah)end;function MathUtil.angleSSS(m,n,Q)if m+n<Q or m+Q<n or n+Q<m then return nil end;local ai=math.deg(math.acos((n*n+Q*Q-m*m)/(2*n*Q)))local aj,ak=MathUtil.angleSAS(n,ai,Q)return ai,aj,ak end;function MathUtil.sideSAS(m,ak,n)local al=m*m+n*n-2*m*n*math.cos(math.rad(ak))return math.sqrt(al)end;function MathUtil.angleSAS(m,ak,n)local Q=MathUtil.sideSAS(m,ak,n)if MathUtil.isZero(Q)then return nil end;local ai,aj;if m<n then ai=MathUtil.angleLoSin(Q,m,ak)aj=180-ai-ak else aj=MathUtil.angleLoSin(Q,n,ak)ai=180-aj-ak end;return ai,aj end;function MathUtil.sideSSA(m,n,ai)local am=n*n-m*m;local an=-2*n*math.cos(math.rad(ai))local ao,ap=MathUtil.solveQuadratic(1,an,am)if not ap then return ao,ap end;if ao<ap then return ao,ap end;return ap,ao end;function MathUtil.angleSSA(m,n,ai)local ao,ap=MathUtil.sideSSA(m,n,ai)if not ao then return nil end;local aq,ar=MathUtil.angleSAS(n,ai,ao)if not ap then return aq,ar end;local as,at=MathUtil.angleSAS(n,ai,ap)return aq,ar,as,at end;function MathUtil.sideAAS(ai,aj,m)local ak=180-ai-aj;local n=MathUtil.sideLoSin(ai,aj,m)local Q=MathUtil.sideLoSin(ai,ak,m)return n,Q end;function MathUtil.sideLoSin(m,ai,aj)return m*math.sin(math.rad(aj))/math.sin(math.rad(ai))end;function MathUtil.angleLoSin(m,n,ai)return math.deg(math.asin(n*math.sin(math.rad(ai))/m))end;function MathUtil.clampCone(au,av,aw)local ax=math.min(aw,Vector3.Angle(au,av))local ay=Vector3.Cross(au,av)return Quaternion.AngleAxis(ax,ay)*au end;function MathUtil.newton(az,aA,aB,aC,aD,aE)aC=aC or 1e-5;aE=aE or 10*aC;aD=aD or 25;aA=aA or function(aF)return(az(aF+aE)-az(aF))/aE end;aB=aB or 0;local aG=aC+1;local aH=0;while aG>aC and aH<aD do local aI=az(aB)local aJ=aA(aB)if not aI or not aJ then return nil end;aG=-aI/aJ;aB=aB+aG;aH=aH+1 end;if aH<aD then return aB,false end;return aB,true end;function MathUtil.ITP(az,m,n,aC,aD)if az(m)*az(n)>0 then return nil end;local aK;if az(m)>az(n)then aK=function(aF)return-az(aF)end else aK=az end;aC=aC or 1e-5;aD=aD or 25;local aL=0.2/(n-m)local aM=2;local aN=1;local aO=math.ceil(math.log((n-m)/(2*aC),2))local aP=aO+aN;local Y=0;while n-m>2*aC and Y<aD do local aQ=(m+n)/2;local aR=(n*az(m)-m*az(n))/(az(m)-az(n))local aS=aQ-aR;local aT=aL*math.abs(n-m)^aM;local aU=aS>0 and 1 or(aS==0 and 0 or-1)local aV=aT<=math.abs(aS)and aR+aU*aT or aQ;local aW=aC*2^(aP-Y)-(n-m)/2;local aX=math.abs(aV-aQ)<=aW and aV or aQ-aU*aW;local aY=az(aX)if aY>0 then n=aX elseif aY<0 then m=aX else m=aX;n=aX end;Y=Y+1 end;return(m+n)/2,Y==aD end;function MathUtil.binomCoeffs(aZ,a_)if a_ then coeffs={}else coeffs={}coeffs[1]=1;for _=1,aZ do coeffs[_+1]=coeffs[_]*(aZ-_)/(_+1)end;return coeffs end end;function MathUtil.ruleOfSigns(coeffs,b0)local b1={}local b2=#coeffs;for F=1,b2 do b1[F]=coeffs[b2-F+1]end;if b0~=0 then local b3={}for F=1,b2 do b3[F]=(F-1)*coeffs[b2-F+1]end;local b4=1;for F=2,b2 do local b5=b0^(F-1)for Y=1,b2-F+1 do local b6=F+Y-1;b1[Y]=b1[Y]+b4*b3[b6]*b5;b3[b6]=b3[b6]*(Y-1)end;b4=b4/F end end;local b7={}local o=1;for F,b8 in ipairs(b1)do if b8~=0 then b7[o]=b8;o=o+1 end end;local b9=0;for F=1,#b7-1 do if b7[F]*b7[F+1]<0 then b9=b9+1 end end;return b9 end;function MathUtil.cache(az)local Q={}local ba=getmetatable(Q)or{}function ba.__index(bb,aF)local C=az(aF)bb[aF]=C;return C end;setmetatable(Q,ba)return function(m)return Q[m]end end;function MathUtil.lerp(az,R,S,T,bc)local bd={}for F=1,math.floor((S-R)/T)+1 do bd[F]=az(R+F*T)end;bd.start=R;bd.stop=S;bd.step=T;bd.lval=bc and bd[1]or nil;bd.rval=bc and bd[#bd]or nil;return function(aF)if aF>=bd.stop then return bd.rval end;if aF<=bd.start then return bd.lval end;local F=(aF-bd.start)/bd.step;local be=F%1;F=math.floor(F)return(1-be)*bd[F]+be*bd[F+1]end end;function MathUtil._factorial(o)if o<2 then return 1 end;return MathUtil._factorial(o-1)end;MathUtil.factorial=MathUtil.cache(MathUtil._factorial)MathUtil.eps=1e-9;function MathUtil.isZero(h)return h>-MathUtil.eps and h<MathUtil.eps end;function MathUtil.setTolerance(aC)MathUtil.eps=aC end;function MathUtil.cuberoot(aF)return aF>0 and aF^(1/3)or-math.abs(aF)^(1/3)end;function MathUtil.solveQuadratic(bf,ao,ap)local bg,bh;local ac,bi,bj;ac=ao/(2*bf)bi=ap/bf;bj=ac*ac-bi;if MathUtil.isZero(bj)then bg=-ac;return bg elseif bj<0 then return else local bk=math.sqrt(bj)bg=bk-ac;bh=-bk-ac;return bg,bh end end;function MathUtil.solveCubic(bf,ao,ap,bl)local bg,bh,bm;local bn,bo;local ai,aj,ak;local bp,ac,bi;local bq,bj;ai=ao/bf;aj=ap/bf;ak=bl/bf;bp=ai*ai;ac=1/3*(-(1/3)*bp+aj)bi=0.5*(2/27*ai*bp-1/3*ai*aj+ak)bq=ac*ac*ac;bj=bi*bi+bq;if MathUtil.isZero(bj)then if MathUtil.isZero(bi)then bg=0;bn=1 else local br=MathUtil.cuberoot(-bi)bg=2*br;bh=-br;bn=2 end elseif bj<0 then local bs=1/3*math.acos(-bi/math.sqrt(-bq))local g=2*math.sqrt(-ac)bg=g*math.cos(bs)bh=-g*math.cos(bs+math.pi/3)bm=-g*math.cos(bs-math.pi/3)bn=3 else local bk=math.sqrt(bj)local br=MathUtil.cuberoot(bk-bi)local a0=-MathUtil.cuberoot(bk+bi)bg=br+a0;bn=1 end;bo=1/3*ai;if bn>0 then bg=bg-bo end;if bn>1 then bh=bh-bo end;if bn>2 then bm=bm-bo end;return bg,bh,bm end;function MathUtil.solveQuartic(bf,ao,ap,bl,bt)local bg,bh,bm,bu;local coeffs={}local a4,br,a0,bo;local ai,aj,ak,bj;local bp,ac,bi,ag;local bn=0;ai=ao/bf;aj=ap/bf;ak=bl/bf;bj=bt/bf;bp=ai*ai;ac=-0.375*bp+aj;bi=0.125*bp*ai-0.5*ai*aj+ak;ag=-(3/256)*bp*bp+0.0625*bp*aj-0.25*ai*ak+bj;if MathUtil.isZero(ag)then coeffs[3]=bi;coeffs[2]=ac;coeffs[1]=0;coeffs[0]=1;local bv={MathUtil.solveCubic(coeffs[0],coeffs[1],coeffs[2],coeffs[3])}bn=#bv;bg,bh,bm=bv[1],bv[2],bv[3]elseif MathUtil.isZero(bi)then local bw={MathUtil.solveQuadratic(1,ac,ag)}if bw[1]>=0 then bg=-math.sqrt(bw[1])bh=math.sqrt(bw[1])bn=2 end;if bw[2]>=0 then if bn==0 then bg=-math.sqrt(bw[2])bh=math.sqrt(bw[2])bn=2 else bm=-math.sqrt(bw[2])bu=math.sqrt(bw[2])bn=4 end end else coeffs[3]=0.5*ag*ac-0.125*bi*bi;coeffs[2]=-ag;coeffs[1]=-0.5*ac;coeffs[0]=1;bg,bh,bm=MathUtil.solveCubic(coeffs[0],coeffs[1],coeffs[2],coeffs[3])a4=bg;br=a4*a4-ag;a0=2*a4-ac;if MathUtil.isZero(br)then br=0 elseif br>0 then br=math.sqrt(br)else return end;if MathUtil.isZero(a0)then a0=0 elseif a0>0 then a0=math.sqrt(a0)else return end;coeffs[2]=a4-br;coeffs[1]=bi<0 and-a0 or a0;coeffs[0]=1;do local bv={MathUtil.solveQuadratic(coeffs[0],coeffs[1],coeffs[2])}bn=#bv;bg,bh=bv[1],bv[2]end;coeffs[2]=a4+br;coeffs[1]=bi<0 and a0 or-a0;coeffs[0]=1;if bn==0 then local bv={MathUtil.solveQuadratic(coeffs[0],coeffs[1],coeffs[2])}bn=bn+#bv;bg,bh=bv[1],bv[2]end;if bn==1 then local bv={MathUtil.solveQuadratic(coeffs[0],coeffs[1],coeffs[2])}bn=bn+#bv;bh,bm=bv[1],bv[2]end;if bn==2 then local bv={MathUtil.solveQuadratic(coeffs[0],coeffs[1],coeffs[2])}bn=bn+#bv;bm,bu=bv[1],bv[2]end end;bo=0.25*ai;if bn>0 then bg=bg-bo end;if bn>1 then bh=bh-bo end;if bn>2 then bm=bm-bo end;if bn>3 then bu=bu-bo end;return bg,bh,bm,bu end;function RingBuffer.RingBuffer(bx)local by={}by.buf={}by.capacity=bx;by.size=0;by.head=1;local ba=getmetatable(by)or{}ba.__index=RingBuffer.get;setmetatable(by,ba)return by end;function RingBuffer.isFull(by)return by.size>=by.capacity end;function RingBuffer.setSize(by,bz)by.size=bz end;function RingBuffer.push(by,d)by.buf[(by.head+by.size-1)%by.capacity+1]=d;if by.size==by.capacity then by.head=by.head%by.capacity+1 else by.size=by.size+1 end end;function RingBuffer.pop(by)if by.size==0 then return nil end;local C=by.buf[by.head]by.buf[by.head]=nil;by.head=by.head%by.capacity+1;by.size=by.size-1;return C end;function RingBuffer.get(by,p)if type(p)~=\"number\"or math.floor(p)~=p then return nil end;if p<1 or p>by.size then return nil end;return by.buf[(by.head+p-2)%by.capacity+1]end;VectorN.mt=getmetatable({})or{}VectorN.mt.__add=function(m,n)local bA=type(m)==\"number\"local bB=type(n)==\"number\"if not bA and bB then return n+m end;if bA and not bB then return MathUtil.combine(m,n,function(_,aF,bC)return m+bC end)else return MathUtil.combine(m,n,function(_,aF,bC)return aF+bC end)end end;VectorN.mt.__sub=function(m,n)return m+-n end;VectorN.mt.__mul=function(m,n)local bA=type(m)==\"number\"local bB=type(n)==\"number\"if not bA and bB then return n*m end;if bA and not bB then local z={}for _,a0 in pairs(n)do z[_]=m*a0 end;return z else return MathUtil.combine(m,n,function(_,aF,bC)return aF*bC end)end end;VectorN.mt.__div=function(m,n)local bA=type(m)==\"number\"local bB=type(n)==\"number\"if not bA and bB then return m*1/n end;if bA and not bB then local z={}for _,a0 in pairs(n)do z[_]=m/a0 end;return z else return MathUtil.combine(m,n,function(_,aF,bC)return aF/bC end)end end;VectorN.mt.__unm=function(m)local z={}for _,a0 in pairs(m)do z[_]=-a0 end;return z end;function VectorN.VectorN(B)local bD={}for _,a0 in pairs(B)do if type(a0)==\"table\"then bD[_]=VectorN.VectorN(a0)else bD[_]=a0 end end;setmetatable(bD,VectorN.mt)return bD end;function Control.PID(bE,bF,bG,bH,bI,bJ)local bK={}bK.kP=bE;bK.kI=bF;bK.kD=bG;bK.Iacc=Accumulator.Accumulator(bH,bI)if bJ and bJ~=0 then bK.period=bJ end;return bK end;function Control.processPID(bL,bM,e)bM=bL.period and(bM+bL.period/2)%bL.period-bL.period/2 or bM;local ac=bL.kP*bM;local F,bN=bL.kI*Accumulator.update(bL.Iacc,bM,e)F=F/bN;local h=bL.kD*(bM-(bL.lastError or bM))/e;bL.lastError=bM;return ac+F+h end;function Control.FF(coeffs,bJ)local bO={}bO.coeffs=coeffs;bO.degree=#coeffs-1;if bJ and bJ~=0 then bO.period=bJ end;bO.derivs={}return bO end;function Control.processFF(bL,bP,e)local bQ=0*bP;local bR=bP;local bS=bP;for F=1,bL.degree+1 do bS=bL.derivs[F]bL.derivs[F]=bR;bQ=bQ+bL.coeffs[F]*bR;if bS then local aS=bR-bS;if F==1 and bL.period then aS=(aS+bL.period/2)%bL.period-bL.period/2 end;bR=aS/e else break end end;return bQ end;function Nav.toLocal(bT,bU,bV)local bW=bT-bU;return Quaternion.Inverse(bV)*bW end;function Nav.toGlobal(bX,bU,bV)local bW=bV*bX;return bW+bU end;function Nav.cartToPol(bY)local ag=bY.magnitude;local ah=Vector3.SignedAngle(Vector3.forward,bY,Vector3.up)local bs=90-Vector3.Angle(Vector3.up,bY)return Vector3(ag,ah,bs)end;function Nav.cartToCyl(bY)local bZ=Vector3(bY.x,0,bY.z)local b_=bZ.magnitude;local bs=Vector3.SignedAngle(Vector3.forward,bY,Vector3.up)local a4=bY.y;return Vector3(b_,bs,a4)end;function Nav.polToCart(bY)local ag,ah,bs=bY.x,bY.y,bY.z;local aF=Mathf.Sin(ah)*Mathf.Cos(bs)local bC=Mathf.Sin(bs)local a4=Mathf.Cos(ah)*Mathf.Cos(bs)return ag*Vector3(aF,bC,a4)end;function Nav.cylToCart(bY)local b_,bs,c0=bY.x,bY.y,bY.z;local aF=b_*Mathf.Sin(bs)local bC=c0;local a4=b_*Mathf.Cos(bs)return Vector3(aF,bC,a4)end;function Targeting.firstOrderTargeting(c1,c2,c3)local c4=c1-Vector3.Project(c1,c2)local c5=Vector3.Dot(c2,c1-c4)/c2.sqrMagnitude;local m,n=MathUtil.solveQuadratic(c5-c3*c3,2*c5,c4.sqrMagnitude+c5*c5)local c6=nil;if m and m>=0 then c6=m end;if n and n>=0 and n<m then c6=n end;return c6 and(c1+c6*c2).normalized or nil end;function Targeting.secondOrderTargeting(c1,c7,c8,c3,c9,ca)local m=-0.25*c8.sqrMagnitude;local n=-Vector3.Dot(c7,c8)local Q=-(c7.sqrMagnitude-c3*c3+Vector3.Dot(c1,c8))local h=-2*Vector3.Dot(c1,c7)local bM=-c1.sqrMagnitude;local g;local cb=c8.magnitude;local cc=c7.magnitude;local cd=c1.magnitude;local ce,cf=MathUtil.solveQuadratic(0.5*cb,cc+c3,-cd)local cg=math.max(ce,cf)local ch;local coeffs={0.5*cb,cc-c3,cd}if MathUtil.ruleOfSigns(coeffs,0)==2 then local ci,cj=MathUtil.solveQuadratic(coeffs[1],coeffs[2],coeffs[3])if ci then ch=math.min(ci,cj)end end;if not ch or ch<cg then local bg,bh,bm=MathUtil.solveCubic(4*m,3*n,2*Q,h)if not bm then if bg>cg then ch=bg end else local ci=math.min(bg,bm)local cj=math.max(bg,bm)if ci>cg then ch=ci elseif cj>cg then ch=cj end end;if not ch then return nil end end;local function ck(aF)return bM+aF*(h+aF*(Q+aF*(n+aF*m)))end;g=MathUtil.ITP(ck,cg,ch,1e-4,25)if not g then return nil end;local cl;if g and g>=cg and g<=ch then cl=c1/g+c7+0.5*c8*g end;if cl and cl.sqrMagnitude>=c9*c9 and cl.sqrMagnitude<=ca*ca then return cl,g end end;function Targeting.AIPPN(cm,c1,cn,c2,co)local c7=c2-cn;local cp=Vector3.Dot(-c7,c1.normalized)if cp<=0 then cp=10 end;local cq=c1.magnitude/cp;local cr=Vector3.Cross(c1,c7)/c1.sqrMagnitude;local cs=Vector3.Cross(c1,co)/c1.sqrMagnitude*cq/2;local ct=cr+cs;local cu=Vector3.Cross(ct,c1.normalized)local cv=Vector3.ProjectOnPlane(cu,cn).normalized;local cw=cm*cn.magnitude*ct.magnitude;return cw*cv end;function Targeting.ATPN(cm,c1,cn,c2,co)local c7=c2-cn;local cp=-Vector3.Dot(c7,c1.normalized)if cp<=0 then cp=10 end;local cr=Vector3.Cross(c1,c7)/c1.sqrMagnitude;local cu=Vector3.Cross(cr,c1.normalized)local cx=Vector3.ProjectOnPlane(co,c1)return cm*cp*cu+0.5*cm*co end;function BlockUtil.getWeaponsByName(cy,cz,b9,cA)if DEBUG then cy:Log(\"searching for \"..cz)end;local cB=cy:GetAllSubConstructs()local cC={}b9=b9 or-1;local Q=b9;if not cA or cA==0 or cA==2 then for F=0,cy:GetWeaponCount()-1 do if Q==0 then break end;if cy:GetWeaponBlockInfo(F).CustomName==cz then table.insert(cC,{subIdx=nil,wpnIdx=F})if DEBUG then cy:Log(\"found weapon \"..cz..\" on hull, type \"..cy:GetWeaponInfo(F).WeaponType)end;Q=Q-1 end end end;if not cA or cA==1 or cA==2 then for p=1,#cB do local bo=cB[p]for F=0,cy:GetWeaponCountOnSubConstruct(bo)-1 do if Q==0 then break end;if cy:GetWeaponBlockInfoOnSubConstruct(bo,F).CustomName==cz then table.insert(cC,{subIdx=bo,wpnIdx=F})if DEBUG then cy:Log(\"found weapon \"..cz..\" on subobj \"..bo..\", type \"..cy:GetWeaponInfo(F).WeaponType)end;Q=Q-1 end end end end;if DEBUG then cy:Log(\"weapon count: \"..#cC)end;return cC end;function BlockUtil.getSubConstructsByName(cy,cz,b9)if DEBUG then cy:Log(\"searching for \"..cz)end;local cB=cy:GetAllSubConstructs()local cD={}b9=b9 or-1;local Q=b9;for p=1,#cB do local bo=cB[p]if Q==0 then break end;if cy:GetSubConstructInfo(bo).CustomName==cz then table.insert(cD,bo)if DEBUG then cy:Log(\"found subobj \"..cz)end;Q=Q-1 end end;if DEBUG then cy:Log(\"subobj count: \"..#cD)end;return cD end;function BlockUtil.getBlocksByName(cy,cz,type,b9)if DEBUG then cy:Log(\"searching for \"..cz)end;local cE={}b9=b9 or-1;local Q=b9;for p=0,cy:Component_GetCount(type)-1 do if Q==0 then break end;if cy:Component_GetBlockInfo(type,p).CustomName==cz then table.insert(cE,p)if DEBUG then cy:Log(\"found component \"..cz)end;Q=Q-1 end end;if DEBUG then cy:Log(\"component count: \"..#cE)end;return cE end;function BlockUtil.getWeaponInfo(cy,cF)if cF.subIdx then return cy:GetWeaponInfoOnSubConstruct(cF.subIdx,cF.wpnIdx)end;return cy:GetWeaponInfo(cF.wpnIdx)end;function BlockUtil.getWeaponBlockInfo(cy,cF)if cF.subIdx then return cy:GetWeaponBlockInfoOnSubConstruct(cF.subIdx,cF.wpnIdx)end;return cy:GetWeaponBlockInfo(cF.wpnIdx)end;function BlockUtil.aimWeapon(cy,cF,cG,cH)if cF.subIdx then cy:AimWeaponInDirectionOnSubConstruct(cF.subIdx,cF.wpnIdx,cG.x,cG.y,cG.z,cH)else cy:AimWeaponInDirection(cF.wpnIdx,cG.x,cG.y,cG.z,cH)end end;function BlockUtil.fireWeapon(cy,cF,cH)if cF.subIdx then return cy:FireWeaponOnSubConstruct(cF.subIdx,cF.wpnIdx,cH)end;return cy:FireWeapon(cF.wpnIdx,cH)end;function Combat.pickTarget(cy,cI,cJ)cJ=cJ or function(U,cK)return cK.Priority end;local bP,cL;for F in MathUtil.range(cy:GetNumberOfTargets(cI))do local cK=cy:GetTargetInfo(cI,F)local cM=cJ(cy,cK)if not bP or cM>cL then bP=cK;cL=cM end end;return bP end;function Combat.CheckConstraints(cy,cN,cO,cP)local cQ;if cP then cQ=cy:GetWeaponConstraintsOnSubConstruct(cP,cO)else cQ=cy:GetWeaponConstraints(cO)end;local cR=cy:GetConstructForwardVector()local cS=cy:GetConstructUpVector()local cT=Quaternion.LookRotation(cR,cS)cN=Quaternion.Inverse(cT)*cN;if cQ.InParentConstructSpace and cP then local cU=cy:GetSubConstructInfo(cP).localRotation;cN=Quaternion.inverse(cU)*cN end;local cV=MathUtil.angleOnPlane(Vector3.forward,cN,Vector3.up)local cW=cN;cW.z=0;local O=Mathf.Atan2(cN.z,cW.magnitude)local cX=cV>cQ.MinAzimuth and cV<cQ.MaxAzimuth;local cY=O>cQ.MinElevation and O<cQ.MaxElevation;if cQ.FlipAzimuth then cX=not cX end;if cX and cY then return true end;cV=cV+180;O=180-O;if O>180 then O=O-360 end;if O<-180 then O=O+360 end;cX=cV>cQ.MinAzimuth and cV<cQ.MaxAzimuth;cY=O>cQ.MinElevation and O<cQ.MaxElevation;if cQ.FlipAzimuth then cX=not cX end;if cX and cY then return true end;return false end;function StringUtil.LogVector(cy,bD,cZ)cy:Log(cZ..\"(\"..bD.x..\", \"..bD.y..\", \"..bD.z..\")\")end\r\n"],"BlockStringDataIds":[41],"GameVersion":"3.6.0.8","PersistentSubObjectIndex":8,"PersistentBlockIndex":88,"AuthorDetails":{"Valid":true,"ForeignBlocks":0,"CreatorId":"051780ed-f58a-41a6-b60f-84fb260c1b22","ObjectId":"fe5bb7da-f3e9-4d92-acd2-f7002e9544b0","CreatorReadableName":"DreekFire","HashV1":"a5598512ea30c7b3f81210225838b965"},"BlockCount":794}}