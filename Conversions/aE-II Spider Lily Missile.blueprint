{"FileModelVersion":{"Major":1,"Minor":0},"Name":"aE-II Spider Lily Missile","Version":27,"SavedTotalBlockCount":26,"SavedMaterialCost":3597.0,"ContainedMaterialCost":0.0,"ItemDictionary":{"1640":"cac80cc3-1d8e-4c2e-b904-09ba3374f940","163":"58ae1262-6ccd-48ca-ac6f-2eb825aa7b42","496":"06484d1a-d956-49a4-b9de-e779696d001c","474":"d3924bae-be5a-43a0-be19-64fc7c8d6059","301":"26a604f0-071c-49ca-8a0e-e1d9c959b1c5","141":"87c9eeec-3ef0-4735-a595-eb5fbf0e66ca","81":"75a78e48-0848-45ee-9df2-e2b328c1933d","82":"275b820d-dd55-49aa-9b09-48b58e8ab5da","151":"c7d3ffb8-3ceb-40ae-a2b0-69c1f4d59462","146":"cacc9c8b-9149-4adf-a86c-5cf5f4b035b8","144":"26a852c0-da52-4232-8e04-69913c8edc13","156":"fcffecd8-0550-4ff6-b85e-36f45cf04be1","274":"b63b85fc-685e-454f-8f93-31db02b95a05","157":"7489ebd4-92d2-4641-9db4-139bb592fc34","605":"e63040c9-0027-4fd3-be30-67fe3e950140"},"Blueprint":{"ContainedMaterialCost":0.0,"CSI":[0.0,0.0,-1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,250.0,4.08684778213501,1.0,1.0,0.0,1.0,169.940445,531.8425,-1.0,0.0,250.0,1.0,1.0,0.0,0.0,0.0,0.0,6.8000001907348633,20.0,0.1,0.1,1.0,1.0,3.0,0.0,0.0,3999.13574,0.0,3.0,1.0,0.0,100.0,0.0,0.0,0.0,0.0,0.0,0.0,39.0,-1.0,23.599998474121094,0.0,0.1625,0.0,0.0,500.0,0.0,12.0,0.0,0.0,0.00875,1.5499026775360107,0.0,0.0,0.0,4.08684778213501,0.0,0.0,0.0,0.0,0.0,1.0,1.0,-1.0,-1.0,-1.0,-1.0],"COL":["0.011764,0,0,0","1,0,0,0.5","0,1,0,0.5","0,0,1,0.5","0.1,0.1,0.1,0.5","0.3,0.3,0.3,0.5","0.5,0.5,0.5,0.5","1,1,1,0.1","1,1,1,0.5","1,1,1,0.99","1,0.921568,0.015686,0.99","0,1,1,0.99","1,0,1,0.99","0.864626,0.434472,0.299871,0.828378","0.586869,0.457345,0.919997,0.259799","0.758084,0.087803,0.970369,0.217299","0.276548,0.957477,0.582312,0.015006","0.903853,0.73457,0.010718,0.837852","0.704795,0.930329,0.158059,0.448773","0.181419,0.358234,0.140033,0.07254","0.614556,0.703575,0.675773,0.554264","0.612402,0.350909,0.144586,0.884375","0.370666,0.181325,0.581195,0.770752","0.620983,0.602118,0.377514,0.740896","0.901199,0.558145,0.781935,0.291857","0.309837,0.247915,0.670469,0.101442","0.340285,0.180928,0.158589,0.924019","0,0,0,0","0.188235,0,0.4,0.5","0.019607,1,1,1","0.980392,1,1,1","0,0,0,1"],"SCs":[],"BLP":["0,1,-4","1,0,-4","-1,0,-4","0,-1,-4","0,0,-4","0,0,3","0,0,1","0,0,0","0,0,-1","0,0,-3","1,0,-6","0,1,-6","-1,0,-6","0,-1,-6","0,0,-6","0,0,-5","0,0,-7","-1,0,-5","0,-1,-5","1,0,-5","0,1,-5","0,0,-2","0,1,-7","0,-1,-7","1,0,-7","-1,0,-7"],"BLR":[11,1,15,5,0,16,6,0,0,4,0,0,0,0,0,0,0,18,12,16,0,22,0,12,16,18],"BP1":null,"BP2":null,"BCI":[0,0,0,0,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"BEI":null,"BlockData":"BgAABwAAAAcAXRsBAAAAAAAABFoAAAAHAAAHAAAABwBdGwEAAAAAAAAEXAAAAAgAACoAAACjAA8nAAAAAACEzQAAABoAAAAAAABuAIXNAAAAnACGzQAAAJwAXRsBAACcAAAAEHJxiWxh+0xDpwgy+dQYIHQBAAQAAAAAAwAEAAAAAEABBArXIzxCAQTNzMw9pAEECtcjPKYBBM3MzD3QBwQDAAAA0QcEAAAAANIHBAAAAADTBwQAgDtF1AcEAABIQtUHBAAAIEHaBwQBAAAAAAAEAAAAAAEABAAAAAADAAQAAMhCKCMWeIfT2et5vUK71vN/NPb+X0NoYXJnZQAABF0AAAAKAAAVAAAABwDmAgAAAAAAXQAAAAAHAF0bAQAABwACAAQAAIA/DAAAFQAAAAcA5gIAAAAAAF0AAAAABwBdGwEAAAcAAgAEAACAvw4AACMAAAAVAIkAAAAAAADsYgAAAAAAhnsAAAAAAF0AAAAADgBdGwEAAA4ABAAEAACAPwcABAAAgD8AAARhAAAA","VehicleData":"Vy4AAAAAAAAHAAAAAAAAAAAAAAAA8FsKAQAAAAAOAAAAAAAPJwAAAAAA0AcAAAAAAJ9xBAAAAAAADgAAAAAADycAAAAAAKCGAQAAAABHKQEAAAAAAAcAAAAAAAAAAAAAAADBfVafAAAAAAcAAAAHAAAAAAAAAAAAAAQBAAAAOe0HAAAAAAAHAAAABwABAAAAAAAAAQAE3AErOj41FAAAAAAABwAAACMAAQAAAAAAAAoABM3MzD0LAATNzMw9DAAEzczMPQ0ABM3MzD0OAATNzMw9UkMAAAAAAAAHAAAAAAABAAAAAAAAxEoAAAAAAAAHAAAADgAAAAAAAAAAAAAEnZyJSAMABKpK00Ur3goAAAAAAAcAAAAIAAEAAAAAAAAAAAEBAQABATKOUAAAAAAABwAAAAAAAAAAAAAAANCrZQAAAAAADgAAAAwAAAAAAAAAAAEAAAAADAAAAAEBAQABAQQAAQEuywQAAAAAAAcAAAAAACSIAAAAAADCJ2EAAAAAAAcAAABGAAAAAAAAAAAAAAQAAEhCCgAEAADIwQ8ABAAAXEIUAAQAAPpDGQAEAIA7RTIABABAHEY3AAQAQBxGHgAEAACAPyMABAAAgD8oAAQAAKBBEugBAAAAAAAOAAAAAAAPJwAAAAAAoIYBAAAAAA==","designChanged":false,"blueprintVersion":27,"blueprintName":"aE-II Spider Lily Missile","SerialisedInfo":{"JsonDictionary":{},"IsEmpty":true},"Name":null,"ItemNumber":605,"LocalPosition":"21194.43,-372.3393,10545.42","LocalRotation":"0.4635242,-0.5327641,0.5418397,0.4557603","ForceId":380137244,"TotalBlockCount":26,"MaxCords":"1,1,3","MinCords":"-1,-1,-7","BlockIds":[1640,1640,1640,1640,163,1640,496,474,301,141,81,82,81,82,151,146,144,156,156,156,156,274,157,157,157,157],"BlockState":"=0,26","AliveCount":26,"BlockStringData":["-- Settings\r\n-- how hard the APN tries to correct for target movement\r\nlocal apnGain = 0.24\r\n-- takes weighted average of TPG and PP guidance\r\n-- set to -1 to use variable weight that scales inversely from 0 to 1\r\nlocal tpgWeight = -1\r\n-- averages target velocity to cancel out oscillations\r\nlocal tpgAveragingTime = 5\r\n-- switches guidance methods based on range\r\nlocal ppRange, tpgRange, apnRange = 10000, 3000, 400\r\n-- if the missile misses, retreat to this range before trying again\r\nlocal retryRange = 100\r\n-- the strength of the evasion (measured in angle off no-evasion path)\n  -- usually won't reach this angle\nlocal evadeStrength = 50\n-- the time before switching evasion directions\r\nlocal evadeTime = 0.35\r\n-- the number of evasion points to use\r\nlocal evadePoints = 5\r\n-- the number of evasion points to jump\r\nlocal evadeStep = 2\r\n\r\n-- Flight settings\r\n-- throttle to use for idle flight\r\nlocal idleThrottle = 0.03\r\n-- whether to use heading or velocity to maneuver\r\nlocal maneuverByVelocity = true\r\nlocal maneuverByVelocityWhenIdle = false\r\n\r\n-- Error is represented by rotation vectors instead of degrees\r\n--   so these should be about 90 times the constants for the built-in PID\r\n-- PID constants for idle flight\r\nlocal kPidle, kIidle, kDidle = 0.009, 0.005, 0.5\r\n-- PID constants for combat\r\nlocal kPcombat, kIcombat, kDcombat = 0.025, 0.005, 0.9\n-- integral term decays by this factor to prevent windup\r\nlocal integralDecay = 0.98\r\n\r\n-- lower and upper altitude limits\r\nlocal altFloorWater, altFloorLand, altCeil = 250, 300, 800\r\n-- altitude to fly at when idling\r\nlocal idleAlt = 300\r\n-- radius to circle at when idling\r\nlocal idleRadius = 500\r\n-- adjuster is turned off within this distance of the target\r\n-- to hit submarine, land, or space targets\r\nlocal altViolationZone = 200\r\n\r\n-- command vehicle list\r\n-- a list of vehicles equipped with datalink cubes\r\nlocal commandVehicleList = {\r\n  [\"M-I Shiranui DDG\"] = {\r\n    offset = Vector3(0.269, 4.016, -39.580),\r\n    axis = Vector3(0, 0, -1),\r\n    maxDist = 50\r\n  }\r\n}\r\n-- time between searching for a new command vehicle\r\nlocal searchTime = 10\r\n\r\n-- misc variables\r\nlocal velList = nil\r\nlocal timesList = nil\r\nlocal target = nil\r\nlocal totalTime = nil\r\nlocal lastTargetVel = nil\r\nlocal lastDesired = nil\r\nlocal currentTargetId = nil\r\nlocal lastFrameTime = nil\r\nlocal commander = nil\r\nlocal lastSearchTime = nil\r\nlocal lastEvadeTime = nil\r\nlocal currentEvadePoint = nil\r\nlocal clusters = {}\r\n\r\nfunction Update(I)\r\n  I:TellAiThatWeAreTakingControl()\r\n\r\n  -- get time elapsed since last frame\r\n  if not lastFrameTime then\r\n    lastFrameTime = I:GetGameTime()\r\n  end\r\n  elapsedTime = I:GetGameTime() - lastFrameTime\r\n  lastFrameTime = I:GetGameTime()\r\n\r\n  if not (commander and commander.vehicle.Valid and commander.vehicle.HealthFraction > 0.5) then\r\n    if not lastSearchTime or I:GetGameTime() - lastSearchTime > searchTime then\r\n      I:Log(\"searching\")\r\n      populateClusters(I)\r\n      findCommander(I)\r\n      lastSearchTime = I:GetGameTime()\r\n    end\r\n  end\r\n\r\n  local desired = nil\r\n  local maneuverSwitch = nil\r\n  -- determine whether to be in combat or idle mode\r\n  if I:GetNumberOfTargets(0) == 0 or not I:GetTargetInfo(0, 0).Valid then\r\n    resetTargetInfo()\r\n\r\n    I:RequestControl(2, 8, idleThrottle)\r\n    kP, kI, kD = kPidle, kIidle, kDidle\r\n    maneuverSwitch = maneuverByVelocityWhenIdle\r\n    desired = Adjust(I, Idle(I))\r\n  else\r\n    if I:GetTargetInfo(0, 0).Id ~= currentTargetId then\r\n      resetTargetInfo()\r\n    end\r\n    currentTargetId = I:GetTargetInfo(0, 0).Id\r\n\r\n    target = I:GetTargetPositionInfo(0, 0)\r\n    circlePoint = nil\r\n\r\n    I:RequestControl(2, 8, 1)\r\n    kP, kI, kD = kPcombat, kIcombat, kDcombat\r\n\r\n    maneuverSwitch = maneuverByVelocity\r\n    desired = finalGuidance(I, target)\r\n    lastTargetVel = target.Velocity\r\n  end\r\n\r\n  --PID\r\n  local ref = maneuverSwitch and I:GetVelocityVector() or I:GetConstructForwardVector()\r\n  local e = Vector3.Cross(desired, ref)\r\n  e = e.normalized * Vector3.Angle(desired, ref)\r\n  local desDiff = lastDes and Quaternion.eulerAngles(Quaternion.FromToRotation(lastDesired, desired)) or Vector3(0, 0, 0)\r\n  local deriv = I:GetAngularVelocity() - desDiff / elapsedTime\r\n\r\n  --P\r\n  local p = kP * e\r\n  --I\r\n  if not angleI or angleI.x ~= angleI.x then\r\n    angleI = Vector3(0, 0, 0)\r\n  end\r\n  local i = kI * angleI\r\n  angleI = integralDecay * angleI + e * elapsedTime\r\n  --D\r\n  local d = kD * deriv\r\n\r\n  lastError = e\r\n\r\n  local correction = p + i + d\r\n\r\n  --steering\r\n  local yawResponse = Vector3.Dot(correction, -I:GetConstructUpVector())\r\n  local pitchResponse = Vector3.Dot(correction, I:GetConstructRightVector())\r\n\r\n  I:RequestControl(2, 1, yawResponse)\r\n  I:RequestControl(2, 4, pitchResponse)\r\nend\r\n\r\nfunction finalGuidance(I, target)\r\n  if target.Range < retryRange and target.Range > 10 then\r\n    local relVel = target.Velocity - I:GetVelocityVector()\r\n    local relPos = target.Position - I:GetConstructPosition()\r\n    local closingVec = -Vector3.Project(relVel, relPos) --negative because it's the missile's velocity\r\n    local closingRate = Vector3.Dot(closingVec, relPos.normalized)\r\n    if closingRate < 0 then\r\n      return Adjust(I, PP(I, target))\r\n    end\r\n  end\r\n  local gd = target.Position - I:GetConstructPosition()\n  gd.y = 0\n  gd = gd.magnitude --target.GroundDistance seems bugged\n  if gd < altViolationZone then\r\n    return APN(I, target)\r\n  end\r\n  if target.Range < apnRange then\r\n    return Adjust(I, evadeTowards(I, APN(I, target)))\r\n  elseif target.Range < tpgRange then\r\n    return Adjust(I, evadeTowards(I, TPG(I, target)))\r\n  elseif target.Range < ppRange then\r\n    return Adjust(I, evadeTowards(I, PP(I, target)))\r\n  else\r\n    I:Log(\"No targets in range\")\r\n    return Adjust(I, Idle(I))\r\n  end\r\nend\r\n\r\nfunction evadeTowards(I, desired)\r\n  if not currentEvadePoint or not lastEvadeTime then\r\n    currentEvadePoint = 0\r\n    lastEvadeTime = I:GetGameTime()\r\n  elseif I:GetGameTime() - lastEvadeTime > evadeTime then\r\n    currentEvadePoint = (currentEvadePoint + evadeStep) % evadePoints\r\n    lastEvadeTime = I:GetGameTime()\r\n  end\r\n  local up = Vector3(0, 1, 0)\r\n  local evadeAxis = Vector3.Cross(Vector3.Cross(desired, up), desired)\r\n  evadeAxis = Quaternion.AngleAxis(currentEvadePoint / evadePoints * 360, desired) * evadeAxis\r\n  return Quaternion.AngleAxis(evadeStrength, evadeAxis) * desired\r\nend\r\n\r\nfunction Adjust(I, desired)\r\n  -- Adjust steering to avoid water, space, and land\r\n  if I:GetConstructPosition().y + 200 * desired.y < altFloorWater then\r\n    desired.y = Mathf.Max(desired.y, (-I:GetConstructPosition().y  + altFloorWater) / 200)\r\n  end\r\n  if I:GetConstructPosition().y + 200 * desired.y > altCeil then\r\n    desired.y = Mathf.Min(desired.y, (-I:GetConstructPosition().y  + altCeil) / 200)\r\n  end\r\n\r\n  return desired.normalized\r\nend\r\n\r\nfunction APN(I, target)\r\n  -- Proportional Navigation (PN) is a guidance method used by early AA missiles\r\n  -- It commands the missile to accelerate perpendicularly to the line of sight (LOS) to the target\r\n  -- and proportional to the rate at which the LOS is rotating\r\n  -- This action can be summarized in many different ways, including:\r\n  -- - pointing the relative velocity vector at the target\r\n  -- - keeping the target at a constant heading\r\n  -- - matching the target's movement perpendicular to the LOS and moving towards it along the LOS\r\n  -- APN is a variant of PN that includes a term to account for target acceleration\r\n  \r\n  -- calculate LOS rotation rate\r\n  local fwv = I:GetForwardsVelocityMagnitude()\r\n  local vel = I:GetVelocityVector()\r\n  local relVel = target.Velocity - vel\r\n  local relPos = target.Position - I:GetConstructPosition()\r\n  local closingVec = -Vector3.Project(relVel, relPos) --negative because it's the missile's velocity\r\n  local closingRate = Vector3.Dot(closingVec, relPos.normalized)\r\n  local dLdt = 180 * (relVel + closingVec) / (Mathf.PI * relPos.magnitude)\r\n  local targetAccel = nil\r\n  local orthoTargetAccel = nil\r\n  if lastTargetVel then\r\n    targetAccel = (target.Velocity - lastTargetVel) / elapsedTime - I:GetGravityForAltitude(target.AltitudeAboveSeaLevel)\r\n    orthoTargetAccel = targetAccel - Vector3.Project(targetAccel, relPos)\r\n  else\r\n    orthoTargetAccel = Vector3(0, 0, 0)\r\n  end\r\n  -- request acceleration according to dLOS/dt and target acceleration\r\n  local accelCommand = (apnGain * Mathf.Min(Mathf.Abs(closingRate), 30) * dLdt) + (0.5 * apnGain * orthoTargetAccel)\r\n\r\n  local orthoVel = vel - Vector3.Project(vel, relPos)\r\n\r\n  local offset = Vector3.ClampMagnitude(accelCommand + orthoVel, fwv)\r\n\r\n  desired = Mathf.Sqrt(Mathf.Max(fwv*fwv - offset.sqrMagnitude, 0)) * relPos.normalized + offset\r\n\r\n  velList = nil\r\n  timesList = nil\r\n  totalTime = nil\r\n\r\n  return desired.normalized\r\nend\r\n\r\nfunction TPG(I, target)\r\n  -- Target Prediction Guidance predicts the target's flight path and intercept it.\r\n  -- Assumes the target will fly in a straight line\r\n  -- Follows the same path a weightless, dragless bullet would take\r\n\r\n  -- average the target velocity over the past [tpgAveragingTime] seconds\r\n  -- for more stable flight\r\n  local avgVel = Vector3(0, 0, 0)\r\n  \r\n  if tpgAveragingTime > 0 then\r\n    if not velList or not timesList then\r\n      velList = {next = nil, previous = nil, first = nil, last = nil, length = 1, value = target.Velocity}\r\n      timesList = {next = nil, previous = nil, first = nil, last = nil, length = 1, value = elapsedTime}\r\n      velList.last = velList\r\n      timesList.last = timesList\r\n    else\r\n      velList = {next = velList, previous = nil, first = nil, last = velList.last, length = velList.length + 1, value = target.Velocity}\r\n      timesList = {next = timesList, previous = nil, first = nil, last = timesList.last, length = timesList.length + 1, value = elapsedTime}\r\n      velList.next.previous = velList\r\n      timesList.next.previous = timesList\r\n    end\r\n    velList.first = velList\r\n    timesList.first = timesList\r\n\r\n    if not totalVel or not totalTime then\r\n      totalVel = Vector3(0, 0, 0)\r\n      totalTime = 0\r\n    end\r\n\r\n    totalVel = totalVel + (velList.first.value * timesList.first.value)\r\n    totalTime = totalTime + timesList.first.value\r\n    while totalTime > tpgAveragingTime and timesList.length > 1 do\r\n      totalVel = totalVel - (velList.last.value * timesList.last.value)\r\n      totalTime = totalTime - timesList.last.value\r\n      velList.last = velList.last.previous\r\n      velList.last.next = nil\r\n      velList.length = velList.length - 1\r\n      timesList.last = timesList.last.previous\r\n      timesList.last.next = nil\r\n      timesList.length = timesList.length - 1\r\n    end\r\n  else\r\n    avgVel = target.Velocity\r\n  end\r\n\r\n  avgVel = totalVel / totalTime\r\n\r\n  --intercept point prediction\r\n  local relPos = target.Position - I:GetConstructPosition()\r\n  local targetAngle = Vector3.Angle(avgVel, relPos)\r\n  if target.Velocity.magnitude * Mathf.Cos(Mathf.PI / 180 * targetAngle) > I:GetForwardsVelocityMagnitude() then\r\n    return PP(I, target)\r\n  end\r\n  local fireAngle = 180 / Mathf.PI * Mathf.Asin(Mathf.Clamp(Mathf.Sin(Mathf.PI / 180 * targetAngle) * avgVel.magnitude / I:GetForwardsVelocityMagnitude(), -1, 1))\r\n  local axis = Vector3.Cross(avgVel, relPos)\r\n\r\n  local currentWeight\r\n  if tpgWeight == -1 then\r\n    currentWeight = apnRange / target.Range\r\n  end\r\n\r\n  local interceptAngle = 180 - fireAngle - targetAngle\r\n  local interceptRange = Mathf.Sin(Mathf.PI / 180 * targetAngle) * (relPos.magnitude / Mathf.Sin(Mathf.PI / 180 * interceptAngle))\r\n  local interceptPoint = Quaternion.AngleAxis(-fireAngle, axis) * relPos.normalized * interceptRange\r\n\r\n  return (interceptPoint * currentWeight + relPos * (1 - currentWeight)).normalized\r\nend\r\n\r\nfunction PP(I, target)\r\n  -- point straight at the target\r\n  local relPos = target.Position - I:GetConstructPosition()\r\n  velList = nil\r\n  timesList = nil\r\n  totalTime = nil\r\n\r\n  return relPos.normalized\r\nend\r\n\r\nfunction Idle(I)\r\n  -- flies in a circle at idleAlt when no target spotted\r\n  local fwv = I:GetForwardsVelocityMagnitude()\r\n  local thrust = 0.6 * I:GetDrive(0) * 6842 / Mathf.Pow(fwv, fwv*fwv/350/350)\r\n\r\n  if not circlePoint then\r\n    circlePoint = I:GetConstructPosition()\r\n  end\r\n\r\n  local radius = I:GetConstructPosition() - circlePoint\r\n  local centripetal = Mathf.Asin(Mathf.Clamp(6.8 * fwv * fwv / idleRadius / thrust, -1, 1))\r\n  radius.y = 0\r\n  local correction = 2 * Mathf.Max(radius.magnitude - idleRadius, 0) - 1 * Vector3.Dot(I:GetVelocityVector(), radius.normalized)\r\n  local prediction = fwv * elapsedTime / idleRadius * 180 / Mathf.PI\r\n  local desired = Quaternion.Euler(0, Mathf.Min(correction + prediction + centripetal, 90), 0) * Vector3.Cross(Vector3(0, 1, 0), radius.normalized)\r\n  desired.y = 0.01 * (idleAlt - I:GetConstructPosition().y) - 0.01 * (I:GetVelocityVector().y)\r\n\r\n  -- missile has no lifting wings, so pitch up to account for gravity\r\n  local pitchRad = I:GetConstructPitch() * Mathf.PI/180\r\n  local gravForce = 6.8 * -I:GetGravityForAltitude(I:GetConstructPosition().y).y\r\n  local pitchGravCorrection = 180/Mathf.PI * Mathf.Asin(Mathf.Clamp(gravForce / thrust, -1, 1))\r\n  desired = Quaternion.AngleAxis(pitchGravCorrection, -Vector3.Cross(Vector3(0, 1, 0), I:GetConstructForwardVector())) * desired\r\n\r\n  return desired.normalized\r\nend\r\n\r\nfunction findCommander(I)\r\n  local closest\r\n  local closestDist\r\n  for i, v in ipairs(clusters) do\r\n    local dist = (I:GetConstructPosition() - v.vehicle.ReferencePosition).magnitude\r\n    if (not closest or dist < closestDist) and v.cubes[1] and v.cubes[2] and v.cubes[3] then\r\n      closest = v\r\n      closestDist = dist\r\n    end\r\n  end\r\n  commander = closest\r\nend\r\n\r\nfunction populateClusters(I)\r\n  for i = 0, I:GetFriendlyCount() - 1 do\r\n    local friendly = I:GetFriendlyInfo(i)\r\n    if friendly.Valid and commandVehicleList[friendly.BlueprintName] then\r\n      table.insert(clusters, {vehicle = friendly, cubes = {}})\r\n    end\r\n  end\r\n  for i = 0, I:GetFriendlyCount() - 1 do\r\n    local friendly = I:GetFriendlyInfo(i)\r\n    if friendly.Valid and string.sub(friendly.BlueprintName, 1, 18) == \"Communication Cube\" then\r\n      local num = tonumber(string.sub(friendly.BlueprintName, 20))\r\n      local closestId\r\n      local closestDist\r\n      for i, v in ipairs(clusters) do\r\n        local dist = (v.vehicle.ReferencePosition - friendly.ReferencePosition).magnitude\r\n        local taken = v.cubes[num] and (v.cubes[num].ReferencePosition - friendly.ReferencePosition).magnitude < dist\r\n        local maxDist = commandVehicleList[clusters[i].vehicle.BlueprintName].maxDist\r\n        if not taken and (not closestId or dist < closestDist) and dist < maxDist then\r\n          closestId = i\r\n          closestDist = dist\r\n        end\r\n      end\r\n      if closestId and closestDist < commandVehicleList[clusters[closestId].vehicle.BlueprintName].maxDist then\r\n        clusters[closestId].cubes[num] = friendly\r\n      end\r\n    end\r\n  end\r\nend\r\n\r\nfunction resetTargetInfo()\r\n  velList = nil\r\n  timesList = nil\r\n  target = nil\r\n\r\n  totalTime = nil\r\n  lastTargetVel = nil\r\n  currentTargetId = nil\r\nend\r\n"],"BlockStringDataIds":[92],"GameVersion":"3.4.1.0","PersistentSubObjectIndex":0,"PersistentBlockIndex":117,"AuthorDetails":{"Valid":true,"ForeignBlocks":0,"CreatorId":"051780ed-f58a-41a6-b60f-84fb260c1b22","ObjectId":"ce7c7310-16d6-431b-9340-de70f11de25e","CreatorReadableName":"DreekFire","HashV1":"43488cf16db2c12d7c9a62d3ae84e2ff"},"BlockCount":26}}