function Accumulator.Accumulator(a,b)local c={}c.decay=b;c.window=a;c.time=0;c.weight=0;if a>0 then c.vals=LinkedList.LinkedList()c.times=LinkedList.LinkedList()end;return c end;function Accumulator.update(c,d,e)local f=Mathf.Pow(c.decay,e)if not c.value then c.value=d*e else c.value=c.value*f;c.value=c.value+d*e end;c.time=c.time+e;c.weight=c.weight*f;c.weight=c.weight+e;if c.window>0 then LinkedList.pushFront(c.vals,d)LinkedList.pushFront(c.times,e)while c.time>c.window do local g=LinkedList.popBack(c.times)c.time=c.time-g;local h=Mathf.Pow(c.decay,c.time)c.weight=c.weight-g*h;c.value=c.value-LinkedList.popBack(c.vals)*g*h end end;return c.value,c.weight end;function Accumulator.get(c)return c.value,c.weight end;function Differ.Differ(i)local j={}j.lastVal=i;j.diff=nil;return j end;function Differ.update(j,d)if j.lastVal then j.diff=d-j.lastVal;j.lastVal=d end;j.lastVal=d;return j.diff end;function Differ.get(j)return j.diff end;function LinkedList.LinkedList()local k={}k.value=nil;k.next=k;k.prev=k;return k end;function LinkedList.pushFront(l,d)local k={}k.value=d;LinkedList.connect(k,l.next)LinkedList.connect(l,k)end;function LinkedList.pushBack(l,d)local k={}k.value=d;LinkedList.connect(l.prev,k)LinkedList.connect(k,l)end;function LinkedList.popFront(l)local m=l.next.value;LinkedList.connect(l,l.next.next)return m end;function LinkedList.popBack(l)local m=l.prev.value;LinkedList.connect(l.prev.prev,l)return m end;function LinkedList.peekFront(l)return l.next.val end;function LinkedList.peekBack(l)return l.prev.val end;function LinkedList.connect(n,o)n.next=o;o.prev=n end;function LinkedList.toArray(l)local p=1;local q={}local k=l.next;while k~=l do q[p]=k.value;k=k.next end;return q end;function MathUtil.angleOnPlane(r,s,t)local u=Vector3.ProjectOnPlane(r,t)local g=Vector3.ProjectOnPlane(s,t)return Vector3.SignedAngle(u,g,t)end;function MathUtil.min(v,w)local x=nil;w=w or function(y,z)return y<z end;for ele in v do if not x or w(ele,x)then x=ele end end;return x end;function MathUtil.max(v,w)local A=nil;w=w or function(y,z)return y<z end;for ele in v do if not A or w(A,ele)then A=ele end end;return A end;function MathUtil.range(y,z,B)local C,D=y,z;local E;if not y then return end;if not z then C=0;D=y;E=C<D and 1 or-1 elseif B then E=B end;return function(F,G)local H=G+E;if H==D then return nil end;return H end,nil,C-E end;function MathUtil.angleSSS(y,z,B)if y+z<B or y+B<z or z+B<y then return nil end;local I=Mathf.Acos((z*z+B*B-y*y)/(2*z*B))*Mathf.Rad2Deg;local J,K=MathUtil.angleSAS(z,I,B)return I,J,K end;function MathUtil.sideSAS(y,K,z)local L=y*y+z*z-2*y*z*Mathf.Cos(K*Mathf.Deg2Rad)return Mathf.Sqrt(L)end;function MathUtil.angleSAS(y,K,z)local B=MathUtil.sideSAS(y,K,z)if MathUtil.isZero(B)then return nil end;local I,J;if y<z then I=MathUtil.angleLoSin(B,y,K)J=180-I-K else J=MathUtil.angleLoSin(B,z,K)I=180-J-K end;return I,J end;function MathUtil.sideSSA(y,z,I)local M=z*z-y*y;local N=-2*z*Mathf.Cos(I*Mathf.Deg2Rad)local O,P=MathUtil.solveQuadratic(M,N,1)if O<P then return O,P end;return P,O end;function MathUtil.angleSSA(y,z,I)local O,P=MathUtil.sideSSA(y,z,I)if not O then return nil end;local Q,R=MathUtil.angleSAS(z,I,O)if not P then return Q,R end;local S,T=MathUtil.angleSAS(z,I,P)return Q,R,S,T end;function MathUtil.sideAAS(I,J,y)local K=180-I-J;local z=MathUtil.sideLoSin(I,J,y)local B=MathUtil.sideLoSin(I,K,y)return z,B end;function MathUtil.sideLoSin(y,I,J)return y*Mathf.Sin(J*Mathf.Deg2Rad)/Mathf.Sin(I*Mathf.Deg2Rad)end;function MathUtil.angleLoSin(y,z,I)return Mathf.Asin(z*Mathf.Sin(I*Mathf.Deg2Rad)/y)*Mathf.Rad2Deg end;function MathUtil.clampCone(U,V,W)local X=Mathf.Min(W,Vector3.Angle(U,V))local Y=Vector3.Cross(U,V)return Quaternion.AngleAxis(X,Y)*U end;local Z=1e-9;function MathUtil.isZero(h)return h>-Z and h<Z end;function MathUtil.cuberoot(_)return _>0 and _^(1/3)or-math.abs(_)^(1/3)end;function MathUtil.solveQuadratic(a0,O,P)local a1,a2;local a3,a4,a5;a3=O/(2*a0)a4=P/a0;a5=a3*a3-a4;if MathUtil.isZero(a5)then a1=-a3;return a1 elseif a5<0 then return else local a6=math.sqrt(a5)a1=a6-a3;a2=-a6-a3;return a1,a2 end end;function MathUtil.solveCubic(a0,O,P,a7)local a1,a2,a8;local a9,aa;local I,J,K;local ab,a3,a4;local ac,a5;I=O/a0;J=P/a0;K=a7/a0;ab=I*I;a3=1/3*(-(1/3)*ab+J)a4=0.5*(2/27*I*ab-1/3*I*J+K)ac=a3*a3*a3;a5=a4*a4+ac;if MathUtil.isZero(a5)then if MathUtil.isZero(a4)then a1=0;a9=1 else local ad=MathUtil.cuberoot(-a4)a1=2*ad;a2=-ad;a9=2 end elseif a5<0 then local ae=1/3*math.acos(-a4/math.sqrt(-ac))local g=2*math.sqrt(-a3)a1=g*math.cos(ae)a2=-g*math.cos(ae+math.pi/3)a8=-g*math.cos(ae-math.pi/3)a9=3 else local a6=math.sqrt(a5)local ad=MathUtil.cuberoot(a6-a4)local af=-MathUtil.cuberoot(a6+a4)a1=ad+af;a9=1 end;aa=1/3*I;if a9>0 then a1=a1-aa end;if a9>1 then a2=a2-aa end;if a9>2 then a8=a8-aa end;return a1,a2,a8 end;function MathUtil.solveQuartic(a0,O,P,a7,ag)local a1,a2,a8,ah;local ai={}local aj,ad,af,aa;local I,J,K,a5;local ab,a3,a4,ak;local a9;I=O/a0;J=P/a0;K=a7/a0;a5=ag/a0;ab=I*I;a3=-0.375*ab+J;a4=0.125*ab*I-0.5*I*J+K;ak=-(3/256)*ab*ab+0.0625*ab*J-0.25*I*K+a5;if MathUtil.isZero(ak)then ai[3]=a4;ai[2]=a3;ai[1]=0;ai[0]=1;local al={MathUtil.solveCubic(ai[0],ai[1],ai[2],ai[3])}a9=#al;a1,a2,a8=al[1],al[2],al[3]else ai[3]=0.5*ak*a3-0.125*a4*a4;ai[2]=-ak;ai[1]=-0.5*a3;ai[0]=1;a1,a2,a8=MathUtil.solveCubic(ai[0],ai[1],ai[2],ai[3])aj=a1;ad=aj*aj-ak;af=2*aj-a3;if MathUtil.isZero(ad)then ad=0 elseif ad>0 then ad=math.sqrt(ad)else return end;if MathUtil.isZero(af)then af=0 elseif af>0 then af=math.sqrt(af)else return end;ai[2]=aj-ad;ai[1]=a4<0 and-af or af;ai[0]=1;do local al={MathUtil.solveQuadratic(ai[0],ai[1],ai[2])}a9=#al;a1,a2=al[1],al[2]end;ai[2]=aj+ad;ai[1]=a4<0 and af or-af;ai[0]=1;if a9==0 then local al={MathUtil.solveQuadratic(ai[0],ai[1],ai[2])}a9=a9+#al;a1,a2=al[1],al[2]end;if a9==1 then local al={MathUtil.solveQuadratic(ai[0],ai[1],ai[2])}a9=a9+#al;a2,a8=al[1],al[2]end;if a9==2 then local al={MathUtil.solveQuadratic(ai[0],ai[1],ai[2])}a9=a9+#al;a8,ah=al[1],al[2]end end;aa=0.25*I;if a9>0 then a1=a1-aa end;if a9>1 then a2=a2-aa end;if a9>2 then a8=a8-aa end;if a9>3 then ah=ah-aa end;return a1,a2,a8,ah end;function RingBuffer.RingBuffer(am)local an={}an.buf={}an.capacity=am;an.tail=1;an.head=1;return an end;function RingBuffer.isFull(an)return(an.head-an.tail)%an.capacity==1 end;function RingBuffer.isEmpty(an)return an.head==an.tail end;function RingBuffer.push(an,d)an.buf[an.tail]=d;if RingBuffer.isFull(an)then an.head=an.head%an.capacity+1 end;an.tail=an.tail%an.capacity+1 end;function RingBuffer.pop(an)if RingBuffer.isEmpty(an)then return nil end;local m=an.buf[an.head]an.buf[an.head]=nil;an.head=an.head%an.capacity+1;return m end;function Control.PID(ao,ap,aq,ar,as,at)local au={}au.kP=ao;au.kI=ap;au.kD=aq;au.Iacc=Accumulator.Accumulator(ar,as)if at and at~=0 then au.period=at end;return au end;function Control.processPID(av,aw,e)aw=av.period and(aw+av.period/2)%av.period-av.period/2 or aw;local a3=av.kP*aw;local p=av.kI*Accumulator.update(av.Iacc,aw,e)local h=av.kD*(aw-(av.lastError or aw))/e;av.lastError=aw;return a3+p+h end;function Control.FF(ai,at)local ax={}ax.coeffs=ai;ax.degree=#ai-1;if at and at~=0 then ax.period=at end;ax.derivs={}return ax end;function Control.processFF(av,ay,e)local az=0*ay;local aA=ay;local aB=ay;for p=1,av.degree+1 do aB=av.derivs[p]av.derivs[p]=aA;az=az+av.coeffs[p]*aA;if aB then local aC=aA-aB;if p==1 and av.period then aC=(aC+av.period/2)%av.period-av.period/2 end;aA=aC/e else break end end;return az end;function Nav.toLocal(aD,aE,aF)local aG=aD-aE;return Quaternion.Inverse(aF)*aG end;function Nav.toGlobal(aH,aE,aF)local aG=aF*aH;return aG+aE end;function Nav.cartToPol(aI)local ak=aI.magnitude;local aJ=Vector3.SignedAngle(Vector3.forward,aI,Vector3.up)local ae=90-Vector3.Angle(Vector3.up,aI)return Vector3(ak,aJ,ae)end;function Nav.cartToCyl(aI)local aK=Vector3(aI.x,0,aI.z)local aL=aK.magnitude;local ae=Vector3.SignedAngle(Vector3.forward,aI,Vector3.up)local aj=aI.y;return Vector3(aL,ae,aj)end;function Nav.polToCart(aI)local ak,aJ,ae=aI.x,aI.y,aI.z;local _=Mathf.Sin(aJ)*Mathf.Cos(ae)local aM=Mathf.Sin(ae)local aj=Mathf.Cos(aJ)*Mathf.Cos(ae)return ak*Vector3(_,aM,aj)end;function Nav.cylToCart(aI)local aL,ae,aN=aI.x,aI.y,aI.z;local _=aL*Mathf.Sin(ae)local aM=aN;local aj=aL*Mathf.Cos(ae)return Vector3(_,aM,aj)end;function Targeting.firstOrderTargeting(aO,aP,aQ)local aR=Vector3.Angle(-aO,aP)local aS=MathUtil.angleSSA(aQ.magnitude,aP.magnitude,aR)return(Quaternion.AngleAxis(aS,Vector3.Cross(aO,aP))*aO).normalized end;function Targeting.secondOrderTargeting(aO,aT,aU,aV,aW,aX)local g=Targeting.secondOrderTargetingTime(aO,aT,aU,aV,aW/aV,aX/aV)if g and g>0 then return(aO/g+aT-0.5*aU*g).normalized end;return nil end;function Targeting.secondOrderTargetingTime(aO,aT,aU,aV,aY,aZ)local y=0.25*aU.sqrMagnitude;local z=Vector3.Dot(aT,aU)local B=aT.sqrMagnitude-aV*aV+Vector3.Dot(aO,aU)local h=2*Vector3.Dot(aO,aT)local aw=aO.sqrMagnitude;local a_={MathUtil.solveQuartic(y,z,B,h,aw)}local g=nil;for p=1,4 do if a_[p]and a_[p]>aY and a_[p]<aZ then if not g or g and a_[p]<g then g=a_[p]end end end;return g end;function Targeting.AIPPN(b0,aO,b1,aP,b2)local aT=aP-b1;local b3=Vector3.Dot(-aT,aO.normalized)if b3<=0 then b3=10 end;local b4=aO.magnitude/b3;local b5=Vector3.Cross(aO,aT)/aO.sqrMagnitude;local b6=Vector3.Cross(aO,b2)/aO.sqrMagnitude*b4/2;local b7=b5+b6;local b8=Vector3.Cross(b7,aO.normalized)local b9=Vector3.ProjectOnPlane(b8,b1).normalized;local ba=b0*b1.magnitude*b7.magnitude;return ba*b9 end;function Targeting.ATPN(b0,aO,b1,aP,b2)local aT=aP-b1;local b3=-Vector3.Dot(aT,aO.normalized)if b3<=0 then b3=10 end;local b5=Vector3.Cross(aO,aT)/aO.sqrMagnitude;local b8=Vector3.Cross(b5,aO.normalized)local bb=Vector3.ProjectOnPlane(b2,aO)return b0*b3*b8+0.5*b0*b2 end;function Targeting.accelToDirection(bc,bd,e)local be=Vector3.Cross(bc,bd)/bc.sqrMagnitude*e*Mathf.Rad2Deg;return Quaternion.AngleAxis(be.magnitude,be)*bc end;function BlockUtil.getWeaponsByName(bf,bg,bh,bi)if DEBUG then bf:Log("searching for "..bg)end;local bj=bf:GetAllSubConstructs()local bk={}bh=bh or-1;local B=bh;if not bi or bi==0 or bi==2 then for p=0,bf:GetWeaponCount()-1 do if B==0 then break end;if bf:GetWeaponBlockInfo(p).CustomName==bg then table.insert(bk,{subIdx=nil,wpnIdx=p})if DEBUG then bf:Log("found weapon "..bg.." on hull, type "..bf:GetWeaponInfo(p).WeaponType)end;B=B-1 end end end;if not bi or bi==1 or bi==2 then for bl=1,#bj do local aa=bj[bl]for p=0,bf:GetWeaponCountOnSubConstruct(aa)-1 do if B==0 then break end;if bf:GetWeaponBlockInfoOnSubConstruct(aa,p).CustomName==bg then table.insert(bk,{subIdx=aa,wpnIdx=p})if DEBUG then bf:Log("found weapon "..bg.." on subobj "..aa..", type "..bf:GetWeaponInfo(p).WeaponType)end;B=B-1 end end end end;if DEBUG then bf:Log("weapon count: "..#bk)end;return bk end;function BlockUtil.getSubConstructsByName(bf,bg,bh)if DEBUG then bf:Log("searching for "..bg)end;local bj=bf:GetAllSubConstructs()local bm={}bh=bh or-1;local B=bh;for bl=1,#bj do local aa=bj[bl]if B==0 then break end;if bf:GetSubConstructInfo(aa).CustomName==bg then table.insert(bm,aa)if DEBUG then bf:Log("found subobj "..bg)end;B=B-1 end end;if DEBUG then bf:Log("subobj count: "..#bm)end;return bm end;function BlockUtil.getBlocksByName(bf,bg,bn,bh)if DEBUG then bf:Log("searching for "..bg)end;local bo={}bh=bh or-1;local B=bh;for bl=0,bf:Component_GetCount(bn)-1 do if B==0 then break end;if bf:Component_GetBlockInfo(bn,bl).CustomName==bg then table.insert(bo,bl)if DEBUG then bf:Log("found component "..bg)end;B=B-1 end end;if DEBUG then bf:Log("component count: "..#bo)end;return bo end;function BlockUtil.getWeaponInfo(bf,bp)local bq;if bp.subIdx then bq=bf:GetWeaponInfoOnSubConstruct(bp.subIdx,bp.wpnIdx)else bq=bf:GetWeaponInfo(bp.wpnIdx)end;return bq end;function BlockUtil.aimWeapon(bf,bp,br,bs)if bp.subIdx then bf:AimWeaponInDirectionOnSubConstruct(bp.subIdx,bp.wpnIdx,br.x,br.y,br.z,bs)else bf:AimWeaponInDirection(bp.wpnIdx,br.x,br.y,br.z,bs)end end;function BlockUtil.fireWeapon(bf,bp,bs)if bp.subIdx then bf:FireWeaponOnSubConstruct(bp.subIdx,bp.wpnIdx,bs)else bf:FireWeapon(bp.wpnIdx,bs)end end;function Combat.pickTarget(bf,bt,bu)bu=bu or function(F,bv)return bv.Priority end;local ay,bw;for p in MathUtil.range(bf:GetNumberOfTargets(bt))do local bv=bf:GetTargetInfo(bt,p)local bx=bu(bf,bv)if not ay or bx>bw then ay=bv;bw=bx end end;return ay end;function CheckConstraints(bf,by,bz,bA)local bB;if bA then bB=bf:GetWeaponConstraintsOnSubConstruct(bA,bz)else bB=bf:GetWeaponConstraints(bz)end;local bC=bf:GetConstructForwardVEctor()local bD=bf:GetConstructUpVector()local bE=Quaternion.LookRotation(bC,bD)by=Quaternion.Inverse(bE)*by;if bB.InParentConstructSpace and bA then local bF=bf:GetSubConstructInfo(bA).localRotation;by=Quaternion.inverse(bF)*by end;local bG=MathUtil.angleOnPlane(Vector3.forward,by,Vector3.up)local bH=by;bH.z=0;local bI=Mathf.Atan2(by.z,bH.magnitude)local bJ=bG>bB.MinAzimuth and bG<bB.MaxAzimuth;local bK=bI>bB.MinElevation and bI<bB.MaxElevation;if bB.FlipAzimuth then bJ=not bJ end;if bJ and bK then return true end;bG=bG+180;ele=180-ele;if ele>180 then ele=ele-360 end;if ele<-180 then ele=ele+360 end;bJ=bG>bB.MinAzimuth and bG<bB.MaxAzimuth;bK=bI>bB.MinElevation and bI<bB.MaxElevation;if bB.FlipAzimuth then bJ=not bJ end;if bJ and bK then return true end;return false end
