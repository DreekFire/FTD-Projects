function Accumulator.Accumulator(a,b)local c={}c.decay=b;c.window=a;c.time=0;c.weight=0;if a>0 then c.vals=LinkedList.LinkedList()c.times=LinkedList.LinkedList()end;return c end;function Accumulator.update(c,d,e)local f=Mathf.Pow(c.decay,e)if not c.value then c.value=d*e else c.value=c.value*f;c.value=c.value+d*e end;c.time=c.time+e;c.weight=c.weight*f;c.weight=c.weight+e;if c.window>0 then LinkedList.pushFront(c.vals,d)LinkedList.pushFront(c.times,e)while c.time>c.window do local g=LinkedList.popBack(c.times)c.time=c.time-g;local h=Mathf.Pow(c.decay,c.time)c.weight=c.weight-g*h;c.value=c.value-LinkedList.popBack(c.vals)*g*h end end;return c.value,c.weight end;function Accumulator.get(c)return c.value,c.weight end;function Differ.Differ(i)local j={}j.lastVal=i;j.diff=nil;return j end;function Differ.update(j,d)if j.lastVal then j.diff=d-j.lastVal;j.lastVal=d end;j.lastVal=d;return j.diff end;function Differ.get(j)return j.diff end;function Heapq.Heapq(i,k)local l={}l.data=i;l.comp=k or function(m,n)return m<n end;local o=#l.data;l.size=o;for p=math.floor(o/2),1,-1 do Heapq.siftDown(l,p)end;return l end;function Heapq.siftDown(l,q)local r=false;local s=q;local o=#l.data;while not r do r=true;local t=2*s;local u=2*s+1;local v=s;if t<=o and l.comp(l.data[t],l.data[v])then v=t;r=false end;if u<=o and l.comp(l.data[u],l.data[v])then v=u;r=false end;if not r then local w=l.data[v]l.data[v]=l.data[s]l.data[s]=w;s=v end end end;function Heapq.siftUp(l,q)local r=false;local s=q;while not r do r=true;local x=math.floor(s/2)if l.comp(l.data[s],l.data[x])then local w=l.data[x]l.data[x]=l.data[s]l.data[s]=w;s=x;r=false end end end;function Heapq.insert(l,y)l.data[l.size+1]=y;l.size=l.size+1;Heapq.siftUp(l,l.size)end;function Heapq.pop(l)local z=l.data[1]l.data[1]=l.data[l.size]l.data[l.size]=nil;l.size=l.size-1;Heapq.siftDown(l,1)return z end;function Heapq.peek(l)return l.data[1]end;function Heapq.size(l)return l.size end;function LinkedList.LinkedList()local A={}A.value=nil;A.next=A;A.prev=A;return A end;function LinkedList.pushFront(B,d)local A={}A.value=d;LinkedList.connect(A,B.next)LinkedList.connect(B,A)end;function LinkedList.pushBack(B,d)local A={}A.value=d;LinkedList.connect(B.prev,A)LinkedList.connect(A,B)end;function LinkedList.popFront(B)local C=B.next.value;LinkedList.connect(B,B.next.next)return C end;function LinkedList.popBack(B)local C=B.prev.value;LinkedList.connect(B.prev.prev,B)return C end;function LinkedList.peekFront(B)return B.next.val end;function LinkedList.peekBack(B)return B.prev.val end;function LinkedList.connect(D,E)D.next=E;E.prev=D end;function LinkedList.toArray(B)local F=1;local G={}local A=B.next;while A~=B do G[F]=A.value;A=A.next end;return G end;function MathUtil.angleOnPlane(H,I,J)local K=Vector3.ProjectOnPlane(H,J)local g=Vector3.ProjectOnPlane(I,J)return Vector3.SignedAngle(K,g,J)end;function MathUtil.min(L,M)local N=nil;M=M or function(m,n)return m<n end;for O in L do if not N or M(O,N)then N=O end end;return N end;function MathUtil.max(L,M)local P=nil;M=M or function(m,n)return m<n end;for O in L do if not P or M(P,O)then P=O end end;return P end;function MathUtil.range(m,n,Q)local R,S=m,n;local T;if not m then return end;if not n then R=0;S=m;T=R<S and 1 or-1 elseif Q then T=Q end;return function(U,V)local W=V+T;if W==S then return nil end;return W end,nil,R-T end;function MathUtil.shuffle(B,X)local s=X and B or{}if not X then for F=1,#B do s[F]=B[F]end end;for F=#B,2,-1 do local Y=math.random(F)s[F],s[Y]=s[Y],s[F]end;return s end;function MathUtil.combine(m,n,Z)if#m==#n then local z={}for _,a0 in pairs(m)do z[_]=Z(_,a0,n[_])end;return z end end;function MathUtil.distribution()return{n=0}end;function MathUtil.updateDistribution(a1,a2)a1.n=a1.n+1;if a1.n==1 then a1.mean=a2;a1.covariance={}local h=#a2;for F=1,h do local a3={}for Y=1,h do a3[Y]=0 end;a1.covariance[F]=a3 end else a1.mean=a1.mean+1/(a1.n+1)*a2 end end;function MathUtil.mean(a1)return a1.mean end;function MathUtil.covariance(a1)return a1.cov end;function MathUtil.normal()local a4,a5=MathUtil.boxMuller()return a4 end;function MathUtil.normalPDF(a4)return math.exp(-0.5*a4*a4)/math.sqrt(2*math.pi)end;function MathUtil.normalCDF(a4)local a6=0.2316419;local a7=0.319381530;local a8=-0.356563782;local a9=1.781477937;local aa=-1.821255978;local ab=1.330274429;local g=1/(1+a6*a4)return 1-MathUtil.normalPDF(a4)*(a7*g+a8*g^2+a9*g^3+aa*g^4+ab*g^5)end;function MathUtil.inverseNorm(ac)local ad=ac>=0.5 and ac or-ac;local a4=5.55556*(1-((1-ad)/ad)^0.1186)if ac<0.5 then a4=-a4 end;return a4 end;function MathUtil.boxMuller()local ae=math.random()local af=math.random()af=math.random()af=math.random()local ag=math.sqrt(-2*math.log(ae))local ah=2*math.pi*af;return ag*math.cos(ah),ag*math.sin(ah)end;function MathUtil.angleSSS(m,n,Q)if m+n<Q or m+Q<n or n+Q<m then return nil end;local ai=math.deg(math.acos((n*n+Q*Q-m*m)/(2*n*Q)))local aj,ak=MathUtil.angleSAS(n,ai,Q)return ai,aj,ak end;function MathUtil.sideSAS(m,ak,n)local al=m*m+n*n-2*m*n*math.cos(math.rad(ak))return math.sqrt(al)end;function MathUtil.angleSAS(m,ak,n)local Q=MathUtil.sideSAS(m,ak,n)if MathUtil.isZero(Q)then return nil end;local ai,aj;if m<n then ai=MathUtil.angleLoSin(Q,m,ak)aj=180-ai-ak else aj=MathUtil.angleLoSin(Q,n,ak)ai=180-aj-ak end;return ai,aj end;function MathUtil.sideSSA(m,n,ai)local am=n*n-m*m;local an=-2*n*math.cos(math.rad(ai))local ao,ap=MathUtil.solveQuadratic(1,an,am)if not ap then return ao,ap end;if ao<ap then return ao,ap end;return ap,ao end;function MathUtil.angleSSA(m,n,ai)local ao,ap=MathUtil.sideSSA(m,n,ai)if not ao then return nil end;local aq,ar=MathUtil.angleSAS(n,ai,ao)if not ap then return aq,ar end;local as,at=MathUtil.angleSAS(n,ai,ap)return aq,ar,as,at end;function MathUtil.sideAAS(ai,aj,m)local ak=180-ai-aj;local n=MathUtil.sideLoSin(ai,aj,m)local Q=MathUtil.sideLoSin(ai,ak,m)return n,Q end;function MathUtil.sideLoSin(m,ai,aj)return m*math.sin(math.rad(aj))/math.sin(math.rad(ai))end;function MathUtil.angleLoSin(m,n,ai)return math.deg(math.asin(n*math.sin(math.rad(ai))/m))end;function MathUtil.clampCone(au,av,aw)local ax=math.min(aw,Vector3.Angle(au,av))local ay=Vector3.Cross(au,av)return Quaternion.AngleAxis(ax,ay)*au end;function MathUtil.newton(az,aA,aB,aC,aD,aE)aC=aC or 1e-5;aE=aE or 10*aC;aD=aD or 25;aA=aA or function(aF)return(az(aF+aE)-az(aF))/aE end;aB=aB or 0;local aG=aC+1;local aH=0;while aG>aC and aH<aD do local aI=az(aB)local aJ=aA(aB)if not aI or not aJ then return nil end;aG=-aI/aJ;aB=aB+aG;aH=aH+1 end;if aH<aD then return aB,false end;return aB,true end;function MathUtil.ITP(az,m,n,aC,aD)if az(m)*az(n)>0 then return nil end;local aK;if az(m)>az(n)then az=function(aF)return-az(aF)end end;aC=aC or 1e-5;aD=aD or 25;local aL=0.2/(n-m)local aM=2;local aN=1;local aO=math.ceil(math.log((n-m)/(2*aC),2))local aP=aO+aN;local Y=0;while n-m>2*aC and Y<aD do local aQ=0.5*(m+n)local aR=az(m)-az(n)if aR==0 then return m end;local aS=(n*az(m)-m*az(n))/aR;local aT=aQ-aS;local aU=aL*math.abs(n-m)^aM;local aV=aT>0 and 1 or(aT==0 and 0 or-1)local aW=aU<=math.abs(aT)and aS+aV*aU or aQ;local aX=aC*2^(aP-Y)-0.5*(n-m)local aY=math.abs(aW-aQ)<=aX and aW or aQ-aV*aX;local aZ=az(aY)if aZ>0 then n=aY elseif aZ<0 then m=aY else m=aY;n=aY end;Y=Y+1 end;local aR=az(m)-az(n)if aR~=0 then return(n*az(m)-m*az(n))/aR,Y==aD end;return m,Y==aD end;function MathUtil.binomCoeffs(a_,b0)if b0 then coeffs={}else coeffs={}coeffs[1]=1;for _=1,a_ do coeffs[_+1]=coeffs[_]*(a_-_)/(_+1)end;return coeffs end end;function MathUtil.ruleOfSigns(coeffs,b1)local b2={}local b3=#coeffs;for F=1,b3 do b2[F]=coeffs[b3-F+1]end;if b1~=0 then local b4={}for F=1,b3 do b4[F]=(F-1)*coeffs[b3-F+1]end;local b5=1;for F=2,b3 do local b6=b1^(F-1)for Y=1,b3-F+1 do local b7=F+Y-1;b2[Y]=b2[Y]+b5*b4[b7]*b6;b4[b7]=b4[b7]*(Y-1)end;b5=b5/F end end;local b8={}local o=1;for F,b9 in ipairs(b2)do if b9~=0 then b8[o]=b9;o=o+1 end end;local ba=0;for F=1,#b8-1 do if b8[F]*b8[F+1]<0 then ba=ba+1 end end;return ba end;function MathUtil.cache(az)local Q={}local bb=getmetatable(Q)or{}function bb.__index(bc,aF)local C=az(aF)bc[aF]=C;return C end;setmetatable(Q,bb)return function(m)return Q[m]end end;function MathUtil.lerp(az,R,S,T,bd)local be={}for F=1,math.floor((S-R)/T)+1 do be[F]=az(R+F*T)end;be.start=R;be.stop=S;be.step=T;be.lval=bd and be[1]or nil;be.rval=bd and be[#be]or nil;return function(aF)if aF>=be.stop then return be.rval end;if aF<=be.start then return be.lval end;local F=(aF-be.start)/be.step;local bf=F%1;F=math.floor(F)return(1-bf)*be[F]+bf*be[F+1]end end;function MathUtil._factorial(o)if o<2 then return 1 end;return MathUtil._factorial(o-1)end;MathUtil.factorial=MathUtil.cache(MathUtil._factorial)MathUtil.eps=1e-9;function MathUtil.isZero(h)return h>-MathUtil.eps and h<MathUtil.eps end;function MathUtil.setTolerance(aC)MathUtil.eps=aC end;function MathUtil.cuberoot(aF)return aF>0 and aF^(1/3)or-math.abs(aF)^(1/3)end;function MathUtil.solveQuadratic(bg,ao,ap)local bh,bi;local ac,bj,bk;ac=ao/(2*bg)bj=ap/bg;bk=ac*ac-bj;if MathUtil.isZero(bk)then bh=-ac;return bh elseif bk<0 then return else local bl=math.sqrt(bk)bh=bl-ac;bi=-bl-ac;return bh,bi end end;function MathUtil.solveCubic(bg,ao,ap,bm)local bh,bi,bn;local bo,bp;local ai,aj,ak;local bq,ac,bj;local br,bk;ai=ao/bg;aj=ap/bg;ak=bm/bg;bq=ai*ai;ac=1/3*(-(1/3)*bq+aj)bj=0.5*(2/27*ai*bq-1/3*ai*aj+ak)br=ac*ac*ac;bk=bj*bj+br;if MathUtil.isZero(bk)then if MathUtil.isZero(bj)then bh=0;bo=1 else local bs=MathUtil.cuberoot(-bj)bh=2*bs;bi=-bs;bo=2 end elseif bk<0 then local bt=1/3*math.acos(-bj/math.sqrt(-br))local g=2*math.sqrt(-ac)bh=g*math.cos(bt)bi=-g*math.cos(bt+math.pi/3)bn=-g*math.cos(bt-math.pi/3)bo=3 else local bl=math.sqrt(bk)local bs=MathUtil.cuberoot(bl-bj)local a0=-MathUtil.cuberoot(bl+bj)bh=bs+a0;bo=1 end;bp=1/3*ai;if bo>0 then bh=bh-bp end;if bo>1 then bi=bi-bp end;if bo>2 then bn=bn-bp end;return bh,bi,bn end;function MathUtil.solveQuartic(bg,ao,ap,bm,bu)local bh,bi,bn,bv;local coeffs={}local a4,bs,a0,bp;local ai,aj,ak,bk;local bq,ac,bj,ag;local bo=0;ai=ao/bg;aj=ap/bg;ak=bm/bg;bk=bu/bg;bq=ai*ai;ac=-0.375*bq+aj;bj=0.125*bq*ai-0.5*ai*aj+ak;ag=-(3/256)*bq*bq+0.0625*bq*aj-0.25*ai*ak+bk;if MathUtil.isZero(ag)then coeffs[3]=bj;coeffs[2]=ac;coeffs[1]=0;coeffs[0]=1;local bw={MathUtil.solveCubic(coeffs[0],coeffs[1],coeffs[2],coeffs[3])}bo=#bw;bh,bi,bn=bw[1],bw[2],bw[3]elseif MathUtil.isZero(bj)then local bx={MathUtil.solveQuadratic(1,ac,ag)}if bx[1]>=0 then bh=-math.sqrt(bx[1])bi=math.sqrt(bx[1])bo=2 end;if bx[2]>=0 then if bo==0 then bh=-math.sqrt(bx[2])bi=math.sqrt(bx[2])bo=2 else bn=-math.sqrt(bx[2])bv=math.sqrt(bx[2])bo=4 end end else coeffs[3]=0.5*ag*ac-0.125*bj*bj;coeffs[2]=-ag;coeffs[1]=-0.5*ac;coeffs[0]=1;bh,bi,bn=MathUtil.solveCubic(coeffs[0],coeffs[1],coeffs[2],coeffs[3])a4=bh;bs=a4*a4-ag;a0=2*a4-ac;if MathUtil.isZero(bs)then bs=0 elseif bs>0 then bs=math.sqrt(bs)else return end;if MathUtil.isZero(a0)then a0=0 elseif a0>0 then a0=math.sqrt(a0)else return end;coeffs[2]=a4-bs;coeffs[1]=bj<0 and-a0 or a0;coeffs[0]=1;do local bw={MathUtil.solveQuadratic(coeffs[0],coeffs[1],coeffs[2])}bo=#bw;bh,bi=bw[1],bw[2]end;coeffs[2]=a4+bs;coeffs[1]=bj<0 and a0 or-a0;coeffs[0]=1;if bo==0 then local bw={MathUtil.solveQuadratic(coeffs[0],coeffs[1],coeffs[2])}bo=bo+#bw;bh,bi=bw[1],bw[2]end;if bo==1 then local bw={MathUtil.solveQuadratic(coeffs[0],coeffs[1],coeffs[2])}bo=bo+#bw;bi,bn=bw[1],bw[2]end;if bo==2 then local bw={MathUtil.solveQuadratic(coeffs[0],coeffs[1],coeffs[2])}bo=bo+#bw;bn,bv=bw[1],bw[2]end end;bp=0.25*ai;if bo>0 then bh=bh-bp end;if bo>1 then bi=bi-bp end;if bo>2 then bn=bn-bp end;if bo>3 then bv=bv-bp end;return bh,bi,bn,bv end;function RingBuffer.RingBuffer(by)local bz={}bz.buf={}bz.capacity=by;bz.size=0;bz.head=1;local bb=getmetatable(bz)or{}bb.__index=RingBuffer.get;setmetatable(bz,bb)return bz end;function RingBuffer.isFull(bz)return bz.size>=bz.capacity end;function RingBuffer.push(bz,d)bz.buf[(bz.head+bz.size-1)%bz.capacity+1]=d;if bz.size==bz.capacity then bz.head=bz.head%bz.capacity+1 else bz.size=bz.size+1 end end;function RingBuffer.pop(bz)if bz.size==0 then return nil end;local C=bz.buf[bz.head]bz.buf[bz.head]=nil;bz.head=bz.head%bz.capacity+1;bz.size=bz.size-1;return C end;function RingBuffer.get(bz,p)if type(p)~="number"or math.floor(p)~=p then return nil end;if p<1 or p>bz.size then return nil end;return bz.buf[(bz.head+p-2)%bz.capacity+1]end;function InterpolatedSearch(bA,bB,t,u,bC,bD,bE)bE=bE or 50;local m,n,bF;local bG=0;while u>t do m=bB[t]if m==bC then return t end;if m>bC then return bD and t or nil end;n=bB[u]if n==bC then return u end;if n<bC then return bD and u or nil end;bF=math.floor((bC-m)/(n-m)*(u-t)+t)bF=math.min(math.max(bF,t+1),u-1)if bB[bF]==bC then return bF end;if bC<bB[bF]then if bD and math.abs(bB[bF-1]-bC)>math.abs(bB[bF]-bC)then return bF end;u=bF-1 else if bD and math.abs(bB[bF+1]-bC)>math.abs(bB[bF]-bC)then return bF end;t=bF+1 end;bG=bG+1;if bG>bE then break end end;return bD and t or nil end;VectorN.mt=getmetatable({})or{}VectorN.mt.__add=function(m,n)local bH=type(m)=="number"local bI=type(n)=="number"if not bH and bI then return n+m end;if bH and not bI then return MathUtil.combine(m,n,function(_,aF,bJ)return m+bJ end)else return MathUtil.combine(m,n,function(_,aF,bJ)return aF+bJ end)end end;VectorN.mt.__sub=function(m,n)return m+-n end;VectorN.mt.__mul=function(m,n)local bH=type(m)=="number"local bI=type(n)=="number"if not bH and bI then return n*m end;if bH and not bI then local z={}for _,a0 in pairs(n)do z[_]=m*a0 end;return z else return MathUtil.combine(m,n,function(_,aF,bJ)return aF*bJ end)end end;VectorN.mt.__div=function(m,n)local bH=type(m)=="number"local bI=type(n)=="number"if not bH and bI then return m*1/n end;if bH and not bI then local z={}for _,a0 in pairs(n)do z[_]=m/a0 end;return z else return MathUtil.combine(m,n,function(_,aF,bJ)return aF/bJ end)end end;VectorN.mt.__unm=function(m)local z={}for _,a0 in pairs(m)do z[_]=-a0 end;return z end;function VectorN.VectorN(B)local bK={}for _,a0 in pairs(B)do if type(a0)=="table"then bK[_]=VectorN.VectorN(a0)else bK[_]=a0 end end;setmetatable(bK,VectorN.mt)return bK end;function Control.PID(bL,bM,bN,bO,bP,bQ)local bR={}bR.kP=bL;bR.kI=bM;bR.kD=bN;bR.Iacc=Accumulator.Accumulator(bO,bP)if bQ and bQ~=0 then bR.period=bQ end;return bR end;function Control.processPID(bS,bT,e)bT=bS.period and(bT+bS.period/2)%bS.period-bS.period/2 or bT;local ac=bS.kP*bT;local F,bU=bS.kI*Accumulator.update(bS.Iacc,bT,e)F=F/bU;local h=bS.kD*(bT-(bS.lastError or bT))/e;bS.lastError=bT;return ac+F+h end;function Control.FF(coeffs,bQ)local bV={}bV.coeffs=coeffs;bV.degree=#coeffs-1;if bQ and bQ~=0 then bV.period=bQ end;bV.derivs={}return bV end;function Control.processFF(bS,bC,e)local bW=0*bC;local bX=bC;local bY=bC;for F=1,bS.degree+1 do bY=bS.derivs[F]bS.derivs[F]=bX;bW=bW+bS.coeffs[F]*bX;if bY then local aT=bX-bY;if F==1 and bS.period then aT=(aT+bS.period/2)%bS.period-bS.period/2 end;bX=aT/e else break end end;return bW end;function Nav.toLocal(bZ,b_,c0)local c1=bZ-b_;return Quaternion.Inverse(c0)*c1 end;function Nav.toGlobal(c2,b_,c0)local c1=c0*c2;return c1+b_ end;function Nav.cartToPol(c3)local ag=c3.magnitude;local ah=Vector3.SignedAngle(Vector3.forward,c3,Vector3.up)local bt=90-Vector3.Angle(Vector3.up,c3)return Vector3(ag,ah,bt)end;function Nav.cartToCyl(c3)local c4=Vector3(c3.x,0,c3.z)local c5=c4.magnitude;local bt=Vector3.SignedAngle(Vector3.forward,c3,Vector3.up)local a4=c3.y;return Vector3(c5,bt,a4)end;function Nav.polToCart(c3)local ag,ah,bt=c3.x,c3.y,c3.z;local aF=Mathf.Sin(ah)*Mathf.Cos(bt)local bJ=Mathf.Sin(bt)local a4=Mathf.Cos(ah)*Mathf.Cos(bt)return ag*Vector3(aF,bJ,a4)end;function Nav.cylToCart(c3)local c5,bt,c6=c3.x,c3.y,c3.z;local aF=c5*Mathf.Sin(bt)local bJ=c6;local a4=c5*Mathf.Cos(bt)return Vector3(aF,bJ,a4)end;function Targeting.firstOrderTargeting(c7,c8,c9)local ca=c7-Vector3.Project(c7,c8)local cb=Vector3.Dot(c8,c7-ca)/c8.sqrMagnitude;local m,n=MathUtil.solveQuadratic(cb-c9*c9,2*cb,ca.sqrMagnitude+cb*cb)local cc=nil;if m and m>=0 then cc=m end;if n and n>=0 and n<m then cc=n end;return cc and(c7+cc*c8).normalized or nil end;function Targeting.secondOrderTargeting(c7,cd,ce,c9,cf,cg)local m=-0.25*ce.sqrMagnitude;local n=-Vector3.Dot(cd,ce)local Q=-(cd.sqrMagnitude-c9*c9+Vector3.Dot(c7,ce))local h=-2*Vector3.Dot(c7,cd)local bT=-c7.sqrMagnitude;local g;local ch=ce.magnitude;local ci=cd.magnitude;local cj=c7.magnitude;local ck,cl=MathUtil.solveQuadratic(0.5*ch,ci+c9,-cj)local cm=math.max(ck,cl)local cn;local coeffs={0.5*ch,ci-c9,cj}if MathUtil.ruleOfSigns(coeffs,0)==2 then local co,cp=MathUtil.solveQuadratic(coeffs[1],coeffs[2],coeffs[3])if co then cn=math.min(co,cp)end end;if not cn or cn<cm then local bh,bi,bn=MathUtil.solveCubic(4*m,3*n,2*Q,h)if not bn then if bh>cm then cn=bh end else local co=math.min(bh,bn)local cp=math.max(bh,bn)if co>cm then cn=co elseif cp>cm then cn=cp end end;if not cn then return end end;local function cq(aF)return bT+aF*(h+aF*(Q+aF*(n+aF*m)))end;g=MathUtil.ITP(cq,cm,cn,1e-4,25)if not g then return end;if g>=cm and g<=cn then local cr=c7+cd*g+0.5*ce*g*g;if cr.sqrMagnitude>=cf*cf and cr.sqrMagnitude<=cg*cg then return cr,g end end end;function Targeting.AIPPN(cs,c7,ct,c8,cu)local cd=c8-ct;local cv=Vector3.Dot(-cd,c7.normalized)if cv<=0 then cv=10 end;local cw=c7.magnitude/cv;local cx=Vector3.Cross(c7,cd)/c7.sqrMagnitude;local cy=Vector3.Cross(c7,cu)/c7.sqrMagnitude*cw/2;local cz=cx+cy;local cA=Vector3.Cross(cz,c7.normalized)local cB=Vector3.ProjectOnPlane(cA,ct).normalized;local cC=cs*ct.magnitude*cz.magnitude;return cC*cB end;function Targeting.ATPN(cs,c7,ct,c8,cu)local cd=c8-ct;local cv=-Vector3.Dot(cd,c7.normalized)if cv<=0 then cv=10 end;local cx=Vector3.Cross(c7,cd)/c7.sqrMagnitude;local cA=Vector3.Cross(cx,c7.normalized)local cD=Vector3.ProjectOnPlane(cu,c7)return cs*cv*cA+0.5*cs*cu end;function BlockUtil.getWeaponsByName(bA,cE,ba,cF)if DEBUG then bA:Log("searching for "..cE)end;local cG=bA:GetAllSubConstructs()local cH={}ba=ba or-1;local Q=ba;if not cF or cF==0 or cF==2 then for F=0,bA:GetWeaponCount()-1 do if Q==0 then break end;if bA:GetWeaponBlockInfo(F).CustomName==cE then table.insert(cH,{subIdx=nil,wpnIdx=F})if DEBUG then bA:Log("found weapon "..cE.." on hull, type "..bA:GetWeaponInfo(F).WeaponType)end;Q=Q-1 end end end;if not cF or cF==1 or cF==2 then for p=1,#cG do local bp=cG[p]for F=0,bA:GetWeaponCountOnSubConstruct(bp)-1 do if Q==0 then break end;if bA:GetWeaponBlockInfoOnSubConstruct(bp,F).CustomName==cE then table.insert(cH,{subIdx=bp,wpnIdx=F})if DEBUG then bA:Log("found weapon "..cE.." on subobj "..bp..", type "..bA:GetWeaponInfo(F).WeaponType)end;Q=Q-1 end end end end;if DEBUG then bA:Log("weapon count: "..#cH)end;return cH end;function BlockUtil.getSubConstructsByName(bA,cE,ba)if DEBUG then bA:Log("searching for "..cE)end;local cG=bA:GetAllSubConstructs()local cI={}ba=ba or-1;local Q=ba;for p=1,#cG do local bp=cG[p]if Q==0 then break end;if bA:GetSubConstructInfo(bp).CustomName==cE then table.insert(cI,bp)if DEBUG then bA:Log("found subobj "..cE)end;Q=Q-1 end end;if DEBUG then bA:Log("subobj count: "..#cI)end;return cI end;function BlockUtil.getBlocksByName(bA,cE,type,ba)if DEBUG then bA:Log("searching for "..cE)end;local cJ={}ba=ba or-1;local Q=ba;for p=0,bA:Component_GetCount(type)-1 do if Q==0 then break end;if bA:Component_GetBlockInfo(type,p).CustomName==cE then table.insert(cJ,p)if DEBUG then bA:Log("found component "..cE)end;Q=Q-1 end end;if DEBUG then bA:Log("component count: "..#cJ)end;return cJ end;function BlockUtil.getWeaponInfo(bA,cK)if cK.subIdx then return bA:GetWeaponInfoOnSubConstruct(cK.subIdx,cK.wpnIdx)end;return bA:GetWeaponInfo(cK.wpnIdx)end;function BlockUtil.getWeaponBlockInfo(bA,cK)if cK.subIdx then return bA:GetWeaponBlockInfoOnSubConstruct(cK.subIdx,cK.wpnIdx)end;return bA:GetWeaponBlockInfo(cK.wpnIdx)end;function BlockUtil.aimWeapon(bA,cK,cL,cM)if cK.subIdx then bA:AimWeaponInDirectionOnSubConstruct(cK.subIdx,cK.wpnIdx,cL.x,cL.y,cL.z,cM)else bA:AimWeaponInDirection(cK.wpnIdx,cL.x,cL.y,cL.z,cM)end end;function BlockUtil.fireWeapon(bA,cK,cM)if cK.subIdx then return bA:FireWeaponOnSubConstruct(cK.subIdx,cK.wpnIdx,cM)end;return bA:FireWeapon(cK.wpnIdx,cM)end;function Combat.pickTarget(bA,cN,cO)cO=cO or function(U,cP)return cP.Priority end;local bC,cQ;for F in MathUtil.range(bA:GetNumberOfTargets(cN))do local cP=bA:GetTargetInfo(cN,F)local cR=cO(bA,cP)if not bC or cR>cQ then bC=cP;cQ=cR end end;return bC end;function Combat.CheckConstraints(bA,cS,cT,cU)local cV;if cU then cV=bA:GetWeaponConstraintsOnSubConstruct(cU,cT)else cV=bA:GetWeaponConstraints(cT)end;local cW=bA:GetConstructForwardVector()local cX=bA:GetConstructUpVector()local cY=Quaternion.LookRotation(cW,cX)cS=Quaternion.Inverse(cY)*cS;if cV.InParentConstructSpace and cU then local cZ=bA:GetSubConstructInfo(cU).localRotation;cS=Quaternion.inverse(cZ)*cS end;local c_=MathUtil.angleOnPlane(Vector3.forward,cS,Vector3.up)local d0=cS;d0.z=0;local O=Mathf.Atan2(cS.z,d0.magnitude)local d1=c_>cV.MinAzimuth and c_<cV.MaxAzimuth;local d2=O>cV.MinElevation and O<cV.MaxElevation;if cV.FlipAzimuth then d1=not d1 end;if d1 and d2 then return true end;c_=c_+180;O=180-O;if O>180 then O=O-360 end;if O<-180 then O=O+360 end;d1=c_>cV.MinAzimuth and c_<cV.MaxAzimuth;d2=O>cV.MinElevation and O<cV.MaxElevation;if cV.FlipAzimuth then d1=not d1 end;if d1 and d2 then return true end;return false end;function StringUtil.LogVector(bA,bK,d3)bA:Log(d3 .."("..bK.x..", "..bK.y..", "..bK.z..")")end
