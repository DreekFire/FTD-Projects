function Accumulator.Accumulator(a,b)local c={}c.decay=b;c.window=a;c.time=0;c.weight=0;if a>0 then c.vals=LinkedList.LinkedList()c.times=LinkedList.LinkedList()end;return c end;function Accumulator.update(c,d,e)local f=Mathf.Pow(c.decay,e)if not c.value then c.value=d*e else c.value=c.value*f;c.value=c.value+d*e end;c.time=c.time+e;c.weight=c.weight*f;c.weight=c.weight+e;if c.window>0 then LinkedList.pushFront(c.vals,d)LinkedList.pushFront(c.times,e)while c.time>c.window do local g=LinkedList.popBack(c.times)c.time=c.time-g;local h=Mathf.Pow(c.decay,c.time)c.weight=c.weight-g*h;c.value=c.value-LinkedList.popBack(c.vals)*g*h end end;return c.value,c.weight end;function Accumulator.get(c)return c.value,c.weight end;function Differ.Differ(i)local j={}j.lastVal=i;j.diff=nil;return j end;function Differ.update(j,d)if j.lastVal then j.diff=d-j.lastVal;j.lastVal=d end;j.lastVal=d;return j.diff end;function Differ.get(j)return j.diff end;function LinkedList.LinkedList()local k={}k.value=nil;k.next=k;k.prev=k;return k end;function LinkedList.pushFront(l,d)local k={}k.value=d;LinkedList.connect(k,l.next)LinkedList.connect(l,k)end;function LinkedList.pushBack(l,d)local k={}k.value=d;LinkedList.connect(l.prev,k)LinkedList.connect(k,l)end;function LinkedList.popFront(l)local m=l.next.value;LinkedList.connect(l,l.next.next)return m end;function LinkedList.popBack(l)local m=l.prev.value;LinkedList.connect(l.prev.prev,l)return m end;function LinkedList.peekFront(l)return l.next.val end;function LinkedList.peekBack(l)return l.prev.val end;function LinkedList.connect(n,o)n.next=o;o.prev=n end;function LinkedList.toArray(l)local p=1;local q={}local k=l.next;while k~=l do q[p]=k.value;k=k.next end;return q end;function MathUtil.angleOnPlane(r,s,t)local u=Vector3.ProjectOnPlane(r,t)local g=Vector3.ProjectOnPlane(s,t)return Vector3.SignedAngle(u,g,t)end;function MathUtil.min(v,w)local x=nil;w=w or function(y,z)return y<z end;for A in v do if not x or w(A,x)then x=A end end;return x end;function MathUtil.max(v,w)local B=nil;w=w or function(y,z)return y<z end;for A in v do if not B or w(B,A)then B=A end end;return B end;function MathUtil.range(y,z,C)local D,E=y,z;local F;if not y then return end;if not z then D=0;E=y;F=D<E and 1 or-1 elseif C then F=C end;return function(G,H)local I=H+F;if I==E then return nil end;return I end,nil,D-F end;function MathUtil.shuffle(l)local J={}for p=1,#l do J[p]=l[p]end;for p=#l,2,-1 do local K=math.random(p)J[p],J[K]=J[K],J[p]end;return J end;function MathUtil.combine(y,z,L)if#y==#z then local M={}for N,O in pairs(y)do M[N]=L(N,O,z[N])end;return M end end;function MathUtil.distribution()return{n=0}end;function MathUtil.updateDistribution(P,Q)P.n=P.n+1;if P.n==1 then P.mean=Q;P.covariance={}local h=#Q;for p=1,h do local R={}for K=1,h do R[K]=0 end;P.covariance[p]=R end else P.mean=P.mean+1/(P.n+1)*Q end end;function MathUtil.mean(P)return P.mean end;function MathUtil.covariance(P)return P.cov end;function MathUtil.normal()local S,T=MathUtil.boxMuller()return S end;function MathUtil.normalPDF(S)return math.exp(-0.5*S*S)/math.sqrt(2*math.pi)end;function MathUtil.normalCDF(S)local U=0.2316419;local V=0.319381530;local W=-0.356563782;local X=1.781477937;local Y=-1.821255978;local Z=1.330274429;local g=1/(1+U*S)return 1-MathUtil.normalPDF(S)*(V*g+W*g^2+X*g^3+Y*g^4+Z*g^5)end;function MathUtil.inverseNorm(_)local a0=_>=0.5 and _ or-_;local S=5.55556*(1-((1-a0)/a0)^0.1186)if _<0.5 then S=-S end;return S end;function MathUtil.boxMuller()local a1=math.random()local a2=math.random()a2=math.random()a2=math.random()local a3=math.sqrt(-2*math.log(a1))local a4=2*math.pi*a2;return a3*math.cos(a4),a3*math.sin(a4)end;function MathUtil.angleSSS(y,z,C)if y+z<C or y+C<z or z+C<y then return nil end;local a5=math.deg(math.acos((z*z+C*C-y*y)/(2*z*C)))local a6,a7=MathUtil.angleSAS(z,a5,C)return a5,a6,a7 end;function MathUtil.sideSAS(y,a7,z)local a8=y*y+z*z-2*y*z*math.cos(math.rad(a7))return math.sqrt(a8)end;function MathUtil.angleSAS(y,a7,z)local C=MathUtil.sideSAS(y,a7,z)if MathUtil.isZero(C)then return nil end;local a5,a6;if y<z then a5=MathUtil.angleLoSin(C,y,a7)a6=180-a5-a7 else a6=MathUtil.angleLoSin(C,z,a7)a5=180-a6-a7 end;return a5,a6 end;function MathUtil.sideSSA(y,z,a5)local a9=z*z-y*y;local aa=-2*z*math.cos(math.rad(a5))local ab,ac=MathUtil.solveQuadratic(1,aa,a9)if not ac then return ab,ac end;if ab<ac then return ab,ac end;return ac,ab end;function MathUtil.angleSSA(y,z,a5)local ab,ac=MathUtil.sideSSA(y,z,a5)if not ab then return nil end;local ad,ae=MathUtil.angleSAS(z,a5,ab)if not ac then return ad,ae end;local af,ag=MathUtil.angleSAS(z,a5,ac)return ad,ae,af,ag end;function MathUtil.sideAAS(a5,a6,y)local a7=180-a5-a6;local z=MathUtil.sideLoSin(a5,a6,y)local C=MathUtil.sideLoSin(a5,a7,y)return z,C end;function MathUtil.sideLoSin(y,a5,a6)return y*math.sin(math.rad(a6))/math.sin(math.rad(a5))end;function MathUtil.angleLoSin(y,z,a5)return math.deg(math.asin(z*math.sin(math.rad(a5))/y))end;function MathUtil.clampCone(ah,ai,aj)local ak=math.min(aj,Vector3.Angle(ah,ai))local al=Vector3.Cross(ah,ai)return Quaternion.AngleAxis(ak,al)*ah end;function MathUtil.fourier(am)return"Work in progress"end;function MathUtil.newton(an,ao,ap,aq,ar,as)aq=aq or 1e-5;as=as or 10*aq;ar=ar or 25;ao=ao or function(at)return(an(at+as)-an(at))/as end;ap=ap or 0;local au=aq+1;local av=0;while au>aq and av<ar do local aw=an(ap)local ax=ao(ap)if not aw or not ax then return nil end;au=-aw/ax;ap=ap+au;av=av+1 end;if av<ar then return ap,false end;return ap,true end;function MathUtil.ITP(an,y,z,aq,ar)if an(y)*an(z)>0 then return nil end;if an(y)>an(z)then an=function(at)return-an(at)end end;aq=aq or 1e-5;ar=ar or 25;local ay=0.2/(z-y)local az=2;local aA=1;local aB=math.ceil(math.log((z-y)/(2*aq),2))local aC=aB+aA;local K=0;while z-y>2*aq and K<ar do local aD=(y+z)/2;local aE=(z*an(y)-y*an(z))/(an(y)-an(z))local aF=aD-aE;local aG=ay*math.abs(z-y)^az;local aH=aF>0 and 1 or(aF==0 and 0 or-1)local aI=aG<=math.abs(aF)and aE+aH*aG or aD;local aJ=aq*2^(aC-K)-(z-y)/2;local aK=math.abs(aI-aD)<=aJ and aI or aD-aH*aJ;local aL=an(aK)if aL>0 then z=aK elseif aL<0 then y=aK else y=aK;z=aK end;K=K+1 end;return(y+z)/2,K==ar end;function MathUtil.binomCoeffs(aM,aN)if aN then coeffs={}else coeffs={}coeffs[1]=1;for N=1,aM do coeffs[N+1]=coeffs[N]*(aM-N)/(N+1)end;return coeffs end end;function MathUtil.ruleOfSigns(coeffs,aO)local aP={}local aQ=#coeffs;for p=1,aQ do aP[p]=coeffs[aQ-p+1]end;if aO~=0 then local aR={}for p=1,aQ do aR[p]=(p-1)*coeffs[aQ-p+1]end;local aS=1;for p=2,aQ do local aT=aO^(p-1)for K=1,aQ-p+1 do local aU=p+K-1;aP[K]=aP[K]+aS*aR[aU]*aT;aR[aU]=aR[aU]*(K-1)end;aS=aS/p end end;local aV={}local aW=1;for p,aX in ipairs(aP)do if aX~=0 then aV[aW]=aX;aW=aW+1 end end;local aY=0;for p=1,#aV-1 do if aV[p]*aV[p+1]<0 then aY=aY+1 end end;return aY end;function MathUtil._factorial(aZ,aW)local m=aZ[aZ.size]for p=aZ.size+1,aW do m=m*p;aZ[p]=m end;aZ.size=aW;return m end;MathUtil._factorialCache={1,size=1}MathUtil._factorialMt=getmetatable(MathUtil._factorialCache)or{}MathUtil._factorialMt.__index=MathUtil._factorial;setmetatable(MathUtil._factorialCache,MathUtil._factorialMt)function MathUtil.factorial(aW)return Mathutil._factorialCache[aW]end;MathUtil.eps=1e-9;function MathUtil.isZero(h)return h>-MathUtil.eps and h<MathUtil.eps end;function MathUtil.setTolerance(aq)MathUtil.eps=aq end;function MathUtil.cuberoot(at)return at>0 and at^(1/3)or-math.abs(at)^(1/3)end;function MathUtil.solveQuadratic(a_,ab,ac)local b0,b1;local _,b2,b3;_=ab/(2*a_)b2=ac/a_;b3=_*_-b2;if MathUtil.isZero(b3)then b0=-_;return b0 elseif b3<0 then return else local b4=math.sqrt(b3)b0=b4-_;b1=-b4-_;return b0,b1 end end;function MathUtil.solveCubic(a_,ab,ac,b5)local b0,b1,b6;local b7,b8;local a5,a6,a7;local b9,_,b2;local ba,b3;a5=ab/a_;a6=ac/a_;a7=b5/a_;b9=a5*a5;_=1/3*(-(1/3)*b9+a6)b2=0.5*(2/27*a5*b9-1/3*a5*a6+a7)ba=_*_*_;b3=b2*b2+ba;if MathUtil.isZero(b3)then if MathUtil.isZero(b2)then b0=0;b7=1 else local bb=MathUtil.cuberoot(-b2)b0=2*bb;b1=-bb;b7=2 end elseif b3<0 then local bc=1/3*math.acos(-b2/math.sqrt(-ba))local g=2*math.sqrt(-_)b0=g*math.cos(bc)b1=-g*math.cos(bc+math.pi/3)b6=-g*math.cos(bc-math.pi/3)b7=3 else local b4=math.sqrt(b3)local bb=MathUtil.cuberoot(b4-b2)local O=-MathUtil.cuberoot(b4+b2)b0=bb+O;b7=1 end;b8=1/3*a5;if b7>0 then b0=b0-b8 end;if b7>1 then b1=b1-b8 end;if b7>2 then b6=b6-b8 end;return b0,b1,b6 end;function MathUtil.solveQuartic(a_,ab,ac,b5,bd)local b0,b1,b6,be;local coeffs={}local S,bb,O,b8;local a5,a6,a7,b3;local b9,_,b2,a3;local b7=0;a5=ab/a_;a6=ac/a_;a7=b5/a_;b3=bd/a_;b9=a5*a5;_=-0.375*b9+a6;b2=0.125*b9*a5-0.5*a5*a6+a7;a3=-(3/256)*b9*b9+0.0625*b9*a6-0.25*a5*a7+b3;if MathUtil.isZero(a3)then coeffs[3]=b2;coeffs[2]=_;coeffs[1]=0;coeffs[0]=1;local bf={MathUtil.solveCubic(coeffs[0],coeffs[1],coeffs[2],coeffs[3])}b7=#bf;b0,b1,b6=bf[1],bf[2],bf[3]elseif MathUtil.isZero(b2)then local bg={MathUtil.solveQuadratic(1,_,a3)}if bg[1]>=0 then b0=-math.sqrt(bg[1])b1=math.sqrt(bg[1])b7=2 end;if bg[2]>=0 then if b7==0 then b0=-math.sqrt(bg[2])b1=math.sqrt(bg[2])b7=2 else b6=-math.sqrt(bg[2])be=math.sqrt(bg[2])b7=4 end end else coeffs[3]=0.5*a3*_-0.125*b2*b2;coeffs[2]=-a3;coeffs[1]=-0.5*_;coeffs[0]=1;b0,b1,b6=MathUtil.solveCubic(coeffs[0],coeffs[1],coeffs[2],coeffs[3])S=b0;bb=S*S-a3;O=2*S-_;if MathUtil.isZero(bb)then bb=0 elseif bb>0 then bb=math.sqrt(bb)else return end;if MathUtil.isZero(O)then O=0 elseif O>0 then O=math.sqrt(O)else return end;coeffs[2]=S-bb;coeffs[1]=b2<0 and-O or O;coeffs[0]=1;do local bf={MathUtil.solveQuadratic(coeffs[0],coeffs[1],coeffs[2])}b7=#bf;b0,b1=bf[1],bf[2]end;coeffs[2]=S+bb;coeffs[1]=b2<0 and O or-O;coeffs[0]=1;if b7==0 then local bf={MathUtil.solveQuadratic(coeffs[0],coeffs[1],coeffs[2])}b7=b7+#bf;b0,b1=bf[1],bf[2]end;if b7==1 then local bf={MathUtil.solveQuadratic(coeffs[0],coeffs[1],coeffs[2])}b7=b7+#bf;b1,b6=bf[1],bf[2]end;if b7==2 then local bf={MathUtil.solveQuadratic(coeffs[0],coeffs[1],coeffs[2])}b7=b7+#bf;b6,be=bf[1],bf[2]end end;b8=0.25*a5;if b7>0 then b0=b0-b8 end;if b7>1 then b1=b1-b8 end;if b7>2 then b6=b6-b8 end;if b7>3 then be=be-b8 end;return b0,b1,b6,be end;function RingBuffer.RingBuffer(bh)local bi={}bi.buf={}bi.capacity=bh;bi.size=0;bi.head=1;local bj=getmetatable(bi)or{}bj.__index=RingBuffer.get;setmetatable(bi,bj)return bi end;function RingBuffer.isFull(bi)return bi.size>=bi.capacity end;function RingBuffer.setSize(bi,bk)bi.size=bk end;function RingBuffer.push(bi,d)bi.buf[(bi.head+bi.size-1)%bi.capacity+1]=d;if bi.size==bi.capacity then bi.head=bi.head%bi.capacity+1 else bi.size=bi.size+1 end end;function RingBuffer.pop(bi)if bi.size==0 then return nil end;local m=bi.buf[bi.head]bi.buf[bi.head]=nil;bi.head=bi.head%bi.capacity+1;bi.size=bi.size-1;return m end;function RingBuffer.get(bi,bl)if type(bl)~="number"or math.floor(bl)~=bl then return nil end;if bl<1 or bl>bi.size then return nil end;return bi.buf[(bi.head+bl-2)%bi.capacity+1]end;VectorN.mt=getmetatable({})or{}VectorN.mt.__add=function(y,z)local bm=type(y)=="number"local bn=type(z)=="number"if not bm and bn then return z+y end;if bm and not bn then return MathUtil.combine(y,z,function(N,at,bo)return y+bo end)else return MathUtil.combine(y,z,function(N,at,bo)return at+bo end)end end;VectorN.mt.__sub=function(y,z)return y+-z end;VectorN.mt.__mul=function(y,z)local bm=type(y)=="number"local bn=type(z)=="number"if not bm and bn then return z*y end;if bm and not bn then local M={}for N,O in pairs(z)do M[N]=y*O end;return M else return MathUtil.combine(y,z,function(N,at,bo)return at*bo end)end end;VectorN.mt.__div=function(y,z)local bm=type(y)=="number"local bn=type(z)=="number"if not bm and bn then return y*1/z end;if bm and not bn then local M={}for N,O in pairs(z)do M[N]=y/O end;return M else return MathUtil.combine(y,z,function(N,at,bo)return at/bo end)end end;VectorN.mt.__unm=function(y)local M={}for N,O in pairs(y)do M[N]=-O end;return M end;function VectorN.VectorN(l)local bp={}for N,O in pairs(l)do if type(O)=="table"then bp[N]=VectorN.VectorN(O)else bp[N]=O end end;setmetatable(bp,VectorN.mt)return bp end;function Control.PID(bq,br,bs,bt,bu,bv)local bw={}bw.kP=bq;bw.kI=br;bw.kD=bs;bw.Iacc=Accumulator.Accumulator(bt,bu)if bv and bv~=0 then bw.period=bv end;return bw end;function Control.processPID(bx,by,e)by=bx.period and(by+bx.period/2)%bx.period-bx.period/2 or by;local _=bx.kP*by;local p,bz=bx.kI*Accumulator.update(bx.Iacc,by,e)p=p/bz;local h=bx.kD*(by-(bx.lastError or by))/e;bx.lastError=by;return _+p+h end;function Control.FF(coeffs,bv)local bA={}bA.coeffs=coeffs;bA.degree=#coeffs-1;if bv and bv~=0 then bA.period=bv end;bA.derivs={}return bA end;function Control.processFF(bx,bB,e)local bC=0*bB;local bD=bB;local bE=bB;for p=1,bx.degree+1 do bE=bx.derivs[p]bx.derivs[p]=bD;bC=bC+bx.coeffs[p]*bD;if bE then local aF=bD-bE;if p==1 and bx.period then aF=(aF+bx.period/2)%bx.period-bx.period/2 end;bD=aF/e else break end end;return bC end;function Nav.toLocal(bF,bG,bH)local bI=bF-bG;return Quaternion.Inverse(bH)*bI end;function Nav.toGlobal(bJ,bG,bH)local bI=bH*bJ;return bI+bG end;function Nav.cartToPol(bK)local a3=bK.magnitude;local a4=Vector3.SignedAngle(Vector3.forward,bK,Vector3.up)local bc=90-Vector3.Angle(Vector3.up,bK)return Vector3(a3,a4,bc)end;function Nav.cartToCyl(bK)local bL=Vector3(bK.x,0,bK.z)local bM=bL.magnitude;local bc=Vector3.SignedAngle(Vector3.forward,bK,Vector3.up)local S=bK.y;return Vector3(bM,bc,S)end;function Nav.polToCart(bK)local a3,a4,bc=bK.x,bK.y,bK.z;local at=Mathf.Sin(a4)*Mathf.Cos(bc)local bo=Mathf.Sin(bc)local S=Mathf.Cos(a4)*Mathf.Cos(bc)return a3*Vector3(at,bo,S)end;function Nav.cylToCart(bK)local bM,bc,bN=bK.x,bK.y,bK.z;local at=bM*Mathf.Sin(bc)local bo=bN;local S=bM*Mathf.Cos(bc)return Vector3(at,bo,S)end;function Targeting.firstOrderTargeting(bO,bP,bQ)local bR=bO-Vector3.Project(bO,bP)local bS=Vector3.Dot(bP,bO-bR)/bP.sqrMagnitude;local y,z=MathUtil.solveQuadratic(bS-bQ*bQ,2*bS,bR.sqrMagnitude+bS*bS)local bT=nil;if y and y>=0 then bT=y end;if z and z>=0 and z<y then bT=z end;return bT and(bO+bT*bP).normalized or nil end;function Targeting.secondOrderTargeting(bO,bU,bV,bQ,bW,bX)local y=-0.25*bV.sqrMagnitude;local z=-Vector3.Dot(bU,bV)local C=-(bU.sqrMagnitude-bQ*bQ+Vector3.Dot(bO,bV))local h=-2*Vector3.Dot(bO,bU)local by=-bO.sqrMagnitude;local g;local bY=bV.magnitude;local bZ=bU.magnitude;local b_=bO.magnitude;local c0,c1=MathUtil.solveQuadratic(0.5*bY,bZ+bQ,-b_)local c2=math.max(c0,c1)local c3;local coeffs={0.5*bY,bZ-bQ,b_}if MathUtil.ruleOfSigns(coeffs,0)==2 then local c4,c5=MathUtil.solveQuadratic(coeffs[1],coeffs[2],coeffs[3])c3=math.min(c4,c5)end;if not c3 or c3<c2 then local b0,b1,b6=MathUtil.solveCubic(4*y,3*z,2*C,h)if not b6 then if b0>c2 then c3=b0 end else local c4=math.min(b0,b6)local c5=math.max(b0,b6)if c4>c2 then c3=c4 elseif c5>c2 then c3=c5 end end;if not c3 then return nil end end;local function c6(at)return by+at*(h+at*(C+at*(z+at*y)))end;g=MathUtil.ITP(c6,c2,c3,1e-4,25)local c7;if g and g>=c2 then c7=bO/g+bU+0.5*bV*g end;if c7 and c7.sqrMagnitude>=bW*bW and c7.sqrMagnitude<=bX*bX then return c7,g end end;function Targeting.AIPPN(c8,bO,c9,bP,ca)local bU=bP-c9;local cb=Vector3.Dot(-bU,bO.normalized)if cb<=0 then cb=10 end;local cc=bO.magnitude/cb;local cd=Vector3.Cross(bO,bU)/bO.sqrMagnitude;local ce=Vector3.Cross(bO,ca)/bO.sqrMagnitude*cc/2;local cf=cd+ce;local cg=Vector3.Cross(cf,bO.normalized)local ch=Vector3.ProjectOnPlane(cg,c9).normalized;local ci=c8*c9.magnitude*cf.magnitude;return ci*ch end;function Targeting.ATPN(c8,bO,c9,bP,ca)local bU=bP-c9;local cb=-Vector3.Dot(bU,bO.normalized)if cb<=0 then cb=10 end;local cd=Vector3.Cross(bO,bU)/bO.sqrMagnitude;local cg=Vector3.Cross(cd,bO.normalized)local cj=Vector3.ProjectOnPlane(ca,bO)return c8*cb*cg+0.5*c8*ca end;function BlockUtil.getWeaponsByName(ck,cl,aY,cm)if DEBUG then ck:Log("searching for "..cl)end;local cn=ck:GetAllSubConstructs()local co={}aY=aY or-1;local C=aY;if not cm or cm==0 or cm==2 then for p=0,ck:GetWeaponCount()-1 do if C==0 then break end;if ck:GetWeaponBlockInfo(p).CustomName==cl then table.insert(co,{subIdx=nil,wpnIdx=p})if DEBUG then ck:Log("found weapon "..cl.." on hull, type "..ck:GetWeaponInfo(p).WeaponType)end;C=C-1 end end end;if not cm or cm==1 or cm==2 then for bl=1,#cn do local b8=cn[bl]for p=0,ck:GetWeaponCountOnSubConstruct(b8)-1 do if C==0 then break end;if ck:GetWeaponBlockInfoOnSubConstruct(b8,p).CustomName==cl then table.insert(co,{subIdx=b8,wpnIdx=p})if DEBUG then ck:Log("found weapon "..cl.." on subobj "..b8 ..", type "..ck:GetWeaponInfo(p).WeaponType)end;C=C-1 end end end end;if DEBUG then ck:Log("weapon count: "..#co)end;return co end;function BlockUtil.getSubConstructsByName(ck,cl,aY)if DEBUG then ck:Log("searching for "..cl)end;local cn=ck:GetAllSubConstructs()local cp={}aY=aY or-1;local C=aY;for bl=1,#cn do local b8=cn[bl]if C==0 then break end;if ck:GetSubConstructInfo(b8).CustomName==cl then table.insert(cp,b8)if DEBUG then ck:Log("found subobj "..cl)end;C=C-1 end end;if DEBUG then ck:Log("subobj count: "..#cp)end;return cp end;function BlockUtil.getBlocksByName(ck,cl,type,aY)if DEBUG then ck:Log("searching for "..cl)end;local cq={}aY=aY or-1;local C=aY;for bl=0,ck:Component_GetCount(type)-1 do if C==0 then break end;if ck:Component_GetBlockInfo(type,bl).CustomName==cl then table.insert(cq,bl)if DEBUG then ck:Log("found component "..cl)end;C=C-1 end end;if DEBUG then ck:Log("component count: "..#cq)end;return cq end;function BlockUtil.getWeaponInfo(ck,cr)local cs;if cr.subIdx then cs=ck:GetWeaponInfoOnSubConstruct(cr.subIdx,cr.wpnIdx)else cs=ck:GetWeaponInfo(cr.wpnIdx)end;return cs end;function BlockUtil.aimWeapon(ck,cr,ct,cu)if cr.subIdx then ck:AimWeaponInDirectionOnSubConstruct(cr.subIdx,cr.wpnIdx,ct.x,ct.y,ct.z,cu)else ck:AimWeaponInDirection(cr.wpnIdx,ct.x,ct.y,ct.z,cu)end end;function BlockUtil.fireWeapon(ck,cr,cu)if cr.subIdx then ck:FireWeaponOnSubConstruct(cr.subIdx,cr.wpnIdx,cu)else ck:FireWeapon(cr.wpnIdx,cu)end end;function Combat.pickTarget(ck,cv,cw)cw=cw or function(G,cx)return cx.Priority end;local bB,cy;for p in MathUtil.range(ck:GetNumberOfTargets(cv))do local cx=ck:GetTargetInfo(cv,p)local cz=cw(ck,cx)if not bB or cz>cy then bB=cx;cy=cz end end;return bB end;function Combat.CheckConstraints(ck,cA,cB,cC)local cD;if cC then cD=ck:GetWeaponConstraintsOnSubConstruct(cC,cB)else cD=ck:GetWeaponConstraints(cB)end;local cE=ck:GetConstructForwardVector()local cF=ck:GetConstructUpVector()local cG=Quaternion.LookRotation(cE,cF)cA=Quaternion.Inverse(cG)*cA;if cD.InParentConstructSpace and cC then local cH=ck:GetSubConstructInfo(cC).localRotation;cA=Quaternion.inverse(cH)*cA end;local cI=MathUtil.angleOnPlane(Vector3.forward,cA,Vector3.up)local cJ=cA;cJ.z=0;local A=Mathf.Atan2(cA.z,cJ.magnitude)local cK=cI>cD.MinAzimuth and cI<cD.MaxAzimuth;local cL=A>cD.MinElevation and A<cD.MaxElevation;if cD.FlipAzimuth then cK=not cK end;if cK and cL then return true end;cI=cI+180;A=180-A;if A>180 then A=A-360 end;if A<-180 then A=A+360 end;cK=cI>cD.MinAzimuth and cI<cD.MaxAzimuth;cL=A>cD.MinElevation and A<cD.MaxElevation;if cD.FlipAzimuth then cK=not cK end;if cK and cL then return true end;return false end;function StringUtil.LogVector(ck,bp,cM)ck:Log(cM.."("..bp.x..", "..bp.y..", "..bp.z..")")end
